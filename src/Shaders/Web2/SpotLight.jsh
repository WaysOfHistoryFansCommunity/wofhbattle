{"meta":{"feedback_varyings":null,"interface_block_bindings":null,"sampler_default_values":[["albedoTex",0],["depthTex",5],["fogOfWar",6],["normalsTex",2],["shadowTex",7],["specEmTex",3]],"shader_parameters":[["fragment","sampler2D","albedoTex",1],["fragment","float","angularFadeFactor",1],["fragment","float","attenuationCurvature",1],["fragment","vec4","colorScale",1],["vertex","vec4","colorScale",1],["fragment","float","cosCutoffAngle",1],["fragment","vec3","darkColor",1],["fragment","sampler2D","depthTex",1],["fragment","vec4","fogColor",1],["fragment","vec2","fogNearFar",1],["fragment","sampler2D","fogOfWar",1],["fragment","float","fowInterpolationParameter",1],["fragment","vec4","fowMapScalePosition",1],["fragment","mat4","invProjection",1],["fragment","vec2","invScreenSize",1],["fragment","mat4","invView",1],["fragment","sampler2D","normalsTex",1],["fragment","vec3","position",1],["vertex","vec3","position",1],["vertex","mat3","rotation",1],["fragment","sampler2D","shadowTex",1],["fragment","sampler2D","specEmTex",1],["fragment","vec3","spotDirection",1],["fragment","vec3","viewCameraPosition",1],["vertex","mat4","viewProjection",1]],"vertex_attributes":[[0,"vec3","vertex"]]},"stages":{"fragment":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#ifdef FOG_OF_WAR","uniform sampler2D fogOfWar ;","uniform float fowInterpolationParameter;","float getFogOfWarFactor(in vec2 tc)","{","const float border0 = -0.001;","const float border1 = 1.001;","float clampTo0 = step(border0, tc.x) * (1.0 - step(border1, tc.x)) * step(border0, tc.y) * (1.0 - step(border1, tc.y));","vec2 rg = texture(fogOfWar, tc).rg * clampTo0;","return mix(rg.r, rg.g, fowInterpolationParameter);","}","#else","float getFogOfWarFactor(in vec2 tc) { return 1.0; }","#endif","float worldPosZFromDepth(in float dep, in vec2 texCoord, in vec4 invViewRow2, in mat4 invProjection)","{","float z = dep * 2.0 - 1.0;","vec4 ndcPosition = vec4(texCoord * 2.0 - 1.0, z, 1.0);","vec4 clipSpacePosition = invProjection * ndcPosition;","vec3 viewSpacePosition = clipSpacePosition.xyz / clipSpacePosition.w;","return dot(invViewRow2, vec4(viewSpacePosition, 1.0));","}","vec3 worldPosFromDepth(in float dep, in vec2 texCoord, in mat4 invView, in mat4 invProjection, out vec3 viewSpacePosition)","{","float z = dep * 2.0 - 1.0;","vec4 ndcPosition = vec4(texCoord * 2.0 - 1.0, z, 1.0);","vec4 clipSpacePosition = invProjection * ndcPosition;","viewSpacePosition = clipSpacePosition.xyz / clipSpacePosition.w;","vec4 worldSpacePosition = invView * vec4(viewSpacePosition, 1.0);","return worldSpacePosition.xyz;","}","vec3 worldPosFromDepth(in float dep, in vec2 texCoord, in mat4 invView, in mat4 invProjection)","{","vec3 viewSpacePosition;","return worldPosFromDepth(dep, texCoord, invView, invProjection, viewSpacePosition);","}","vec3 worldPosFromDepth(in vec2 texCoord, in sampler2D depthTex, in mat4 invView, in mat4 invProjection)","{","float dep = texture(depthTex, texCoord).r;","return worldPosFromDepth(dep, texCoord, invView, invProjection);","}","vec3 worldPosFromDepth(in vec2 texCoord, in sampler2D depthTex, in mat4 invView, in mat4 invProjection, out vec3 viewSpacePosition)","{","float dep = texture(depthTex, texCoord).r;","return worldPosFromDepth(dep, texCoord, invView, invProjection, viewSpacePosition);","}","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","uniform sampler2D shadowTex ;","float getBiasedShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in int cascadeId)","{","float bias = shadowBias(normal, lightDirection);","vec3 smc = (sunVertexPosition + vec3(1.0, 1.0, 1.0)) * 0.5;","return getShadow(shadowTex, smc.xy, smc.z, bias, cascadeId);","}","float getWaterBiasedShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in float distortionFactor)","{","vec3 shadowMapCoord = (sunVertexPosition.xyz + vec3(1.0, 1.0, 1.0)) * 0.5;","float bias = shadowBias(normal, lightDirection);","vec2 tc = shadowMapCoord.xy + normal.xy * distortionFactor * 0.1;","return getShadow(shadowTex, tc, shadowMapCoord.z, bias, 0 );","}","void addShadowSpec(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor, inout vec3 totalSpecular)","{","float shadow = getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","sunColor = mix(sunColor, darkColor, shadow);","totalSpecular *= 1.0 - shadow;","}","void addShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor)","{","float shadow = getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","sunColor = mix(sunColor, darkColor, shadow);","}","#else","void addShadowSpec(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor, inout vec3 totalSpecular) {}","void addShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor) {}","#endif","#define PI 3.14159265359","float DistributionGGX(vec3 N, vec3 H, float roughness)","{","float a      = roughness*roughness;","float a2     = a*a;","float NdotH  = max(dot(N, H), 0.0);","float NdotH2 = NdotH*NdotH;","float num   = a2;","float denom = (NdotH2 * (a2 - 1.0) + 1.0);","denom = PI * denom * denom;","return num / max(denom, 0.0000001);","}","float GeometrySchlickGGX(float NdotV, float roughness)","{","float r = (roughness + 1.0);","float k = (r*r) / 8.0;","float num   = NdotV;","float denom = NdotV * (1.0 - k) + k;","return num / denom;","}","float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)","{","float NdotV = max(dot(N, V), 0.0);","float NdotL = max(dot(N, L), 0.0);","float ggx2  = GeometrySchlickGGX(NdotV, roughness);","float ggx1  = GeometrySchlickGGX(NdotL, roughness);","return ggx1 * ggx2;","}","vec3 fresnelSchlick(float cosTheta, vec3 F0)","{","float invCosTheta = 1.0 - cosTheta;","float pow5 = invCosTheta * invCosTheta * invCosTheta * invCosTheta * invCosTheta;","return F0 + (1.0 - F0) * pow5;","}","vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)","{","float invCosTheta = 1.0 - cosTheta;","float pow5 = invCosTheta * invCosTheta * invCosTheta * invCosTheta * invCosTheta;","return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow5;","}","vec3 metallicPbrColor(","in float roughness,","in float metallic,","in float translucency,","in vec3 albedo,","in vec3 lightColor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal",")","{","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = dot(normal, lightDirection);","NdotL = mix(max(NdotL, 0.0), abs(NdotL), translucency);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec\t\t  = numerator / max(denominator, 0.000001);","return (kD * albedo / PI + spec) * lightColor * NdotL;","}","vec3 metallicPbrSunColor(","in float roughness,","in float metallic,","in float translucency,","in float emission,","in vec3 albedo,","in vec3 darkColor,","in vec3 lightColor,","in vec3 envmapSunFactor,","in vec3 envmapShadowFactor,","in vec3 envmapSpecularFactor,","in vec3 sunSpecularFactor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in sampler2D specularBrdfLut,","in samplerCube irradianceMap,","in samplerCube envMap,","in int cascadeId",")","{","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","float shadowFactor = 1.0 - getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","#else","float shadowFactor = 1.0;","#endif","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = dot(normal, lightDirection);","NdotL = mix(max(NdotL, 0.0), abs(NdotL), translucency);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec = numerator / max(denominator, 0.000001);","spec *= sunSpecularFactor * shadowFactor;","vec3 dimLightColor = lightColor * NdotL * shadowFactor;","vec3 diffuseColor = kD * albedo / PI;","vec3 Lo = diffuseColor * max(0.0, 1.0 - emission) * dimLightColor + albedo * emission + spec * dimLightColor;","F = fresnelSchlickRoughness(max(dot(normal, viewDirection), 0.0), F0, roughness);","kD = 1.0 - F;","kD *= 1.0 - metallic;","vec3 irradianceSampleDir = normal.xzy;","irradianceSampleDir.z = -irradianceSampleDir.z;","vec3 irradiance = texture(irradianceMap, irradianceSampleDir).rgb * mix(envmapShadowFactor, envmapSunFactor, NdotL * shadowFactor);","vec3 diffuse = irradiance * albedo;","const float MAX_REFLECTION_LOD = 4.0;","vec3 R = reflect(-viewDirection, normal);","R = R.xzy;","R.z = -R.z;","vec3 prefilteredColor = textureLod(envMap, R,  roughness * MAX_REFLECTION_LOD).rgb;","vec2 brdf  = texture(specularBrdfLut, vec2(max(dot(normal, viewDirection), 0.0), roughness)).rg;","vec3 specular = prefilteredColor * (F * brdf.x + brdf.y) * shadowFactor * envmapSpecularFactor;","vec3 ambient = kD * diffuse + specular;","return Lo + ambient;","}","vec3 waterPbrSunColor(","in float roughness,","in float metallic,","in float specularFactor,","in float distortionFactor,","in vec3 albedo,","in vec3 lightColor,","in vec3 darkColor,","in vec3 envmapSunFactor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in sampler2D specularBrdfLut,","in samplerCube irradianceMap,","in vec3 reflectionColor)","{","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","float shadowFactor = 1.0 - getWaterBiasedShadow(normal, sunVertexPosition, lightDirection, distortionFactor);","#else","float shadowFactor = 1.0;","#endif","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = max(dot(normal, lightDirection), 0.0);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec = numerator / max(denominator, 0.000001);","spec *= shadowFactor * specularFactor;","vec3 dimLightColor = lightColor * NdotL * shadowFactor;","vec3 diffuseColor = kD * albedo / PI;","vec3 Lo = diffuseColor * dimLightColor + spec * dimLightColor;","F = fresnelSchlickRoughness(max(dot(normal, viewDirection), 0.0), F0, roughness);","kD = 1.0 - F;","kD *= 1.0 - metallic;","vec3 irradianceSampleDir = normal.xzy;","irradianceSampleDir.z = -irradianceSampleDir.z;","vec3 irradiance = texture(irradianceMap, irradianceSampleDir).rgb * mix(darkColor, envmapSunFactor, NdotL * shadowFactor);","vec3 diffuse = irradiance * albedo;","const float MAX_REFLECTION_LOD = 4.0;","vec3 R = reflect(-viewDirection, normal);","R = R.xzy;","R.z = -R.z;","vec3 prefilteredColor = reflectionColor;","vec2 brdf  = texture(specularBrdfLut, vec2(max(dot(normal, viewDirection), 0.0), roughness)).rg;","vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);","specular = mix(specular * darkColor, specular, shadowFactor) * albedo;","vec3 ambient = kD * diffuse + specular;","return Lo + ambient;","}","vec3 blinnPhongColor(","in float specular,","in float specularPower,","in float translucency,","in float emission,","in vec3 albedo,","in vec3 darkColor,","in vec3 lightColor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in int cascadeId",")","{","vec3 reflection = -reflect(lightDirection, normal);","float fRdotV = max(0.0, dot(normalize(reflection), viewDirection));","vec3 totalSpecular = lightColor * pow(fRdotV, specularPower) * specular;","float LDdotN = dot(lightDirection, normal);","float lightIntensity = clamp(mix(max(LDdotN, 0.0), abs(LDdotN), translucency), 0.0, 1.0);","vec3 sunColor = mix(darkColor, lightColor, lightIntensity);","addShadowSpec(normal, sunVertexPosition, lightDirection, darkColor, cascadeId, sunColor, totalSpecular);","vec3 outDiffuseColor = albedo * sunColor;","outDiffuseColor = outDiffuseColor * max(0.0, 1.0 - emission) + albedo * emission;","return outDiffuseColor + totalSpecular;","}","uniform sampler2D albedoTex ;","uniform sampler2D normalsTex ;","uniform sampler2D specEmTex ;","uniform sampler2D depthTex ;","uniform vec2 invScreenSize;","uniform vec3 viewCameraPosition;","uniform vec3 darkColor;","uniform vec4 colorScale;","uniform vec3 position;","uniform float cosCutoffAngle;","uniform vec3 spotDirection;","uniform float angularFadeFactor;","uniform float attenuationCurvature;","uniform mat4 invProjection;","uniform mat4 invView;","#ifdef FOG_OF_WAR","uniform vec4 fowMapScalePosition;","#endif","#define radius colorScale.w","#define color colorScale.xyz","#ifdef FOG","uniform vec2 fogNearFar;","uniform vec4 fogColor;","vec3 addFog(in vec3 fColor, in float zEye, in float attenuationFactor)","{","float fogNear = fogNearFar[0];","float fogFar = fogNearFar[1];","return fColor * (1.0 - clamp((zEye - fogNear) / (fogFar - fogNear), 0.0, 1.0) * fogColor.a);","}","#else","vec3 addFog(in vec3 fColor, in float zEye, in float attenuationFactor)","{","return fColor;","}","#endif","const float specularPower = 10.0;","layout(location = 0) out vec4 outFragColor;","#ifdef FOG_OF_WAR","layout(location = 2) out vec4 outFowBuffer;","#endif","void main()","{","#ifdef OVERDRAW","outFragColor = vec4(0.1, 0.0, 0.0, 1.0);","#else","vec2 texCoord = gl_FragCoord.xy * invScreenSize;","vec3 albedo = texture(albedoTex, texCoord).rgb;","vec4 normalTranslucency = texture(normalsTex, texCoord);","vec3 normal = normalTranslucency.xyz;","float translucency = normalTranslucency.a;","vec3 coord = worldPosFromDepth(texCoord, depthTex, invView, invProjection);","vec3 specEm = texture(specEmTex, texCoord).rgb;","normal *= 2.0;","normal -= vec3(1.0);","float specular = 1.0 / specEm.r - 1.0;","const float radialFadeFactor = 0.9;","vec3 fragToPos = position - coord;","float d = length(fragToPos);","float normalizedDistance = max(1.0 - d / radius, 0.0);","float attenuationFactor = mix(normalizedDistance, normalizedDistance * normalizedDistance, attenuationCurvature);","attenuationFactor *= 1.0 - smoothstep(radius * radialFadeFactor, radius, d);","vec3 lightDirection = fragToPos / d;","float LDdotN = dot(lightDirection, normal);","vec3 viewDirection = normalize(viewCameraPosition - coord);","float lightIntensity = clamp(mix(max(LDdotN, 0.0), abs(LDdotN), translucency), 0.0, 1.0);","vec3 lightSourceColor = color * lightIntensity * attenuationFactor;","#ifdef PBR_METALLIC","float roughness = specEm.r;","float metallic = specEm.b;","outFragColor.rgb = metallicPbrColor(roughness, metallic, translucency, albedo, lightSourceColor, viewDirection, lightDirection, normal);","#else","vec3 reflection = reflect(-lightDirection, normal);","float fRdotV = max(0.0, dot(normalize(reflection), viewDirection));","vec3 totalSpecular = color * 2.0 * pow(fRdotV, specularPower) * specular * attenuationFactor;","outFragColor.rgb = albedo * lightSourceColor + totalSpecular;","#endif","float cosAngle = dot(spotDirection, -lightDirection);","float cutoff = step(cosCutoffAngle, cosAngle);","cutoff *= 1.0 - smoothstep(cosAngle * angularFadeFactor, cosAngle, cosCutoffAngle);","outFragColor.rgb *= cutoff;","outFragColor.rgb = addFog(outFragColor.rgb, distance(coord, viewCameraPosition), attenuationFactor);","#ifdef FOG_OF_WAR","vec2 fowTc = coord.xy * fowMapScalePosition.xy + fowMapScalePosition.zw;","float fow = getFogOfWarFactor(fowTc);","outFragColor.rgb *= fow;","outFowBuffer.ra = vec2(0.0, 0.0);","#endif","#endif","outFragColor.a = 1.0;","}"],"vertex":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","vertAttrib(0, vec3, vertex);","uniform vec3 position;","uniform mat4 viewProjection;","uniform vec4 colorScale;","uniform mat3 rotation;","#define scale colorScale.w","void main()","{","gl_Position = viewProjection * vec4(rotation * vertex * scale + position, 1.0);","}"]}}
