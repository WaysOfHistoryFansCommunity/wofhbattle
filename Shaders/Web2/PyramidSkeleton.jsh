{"meta":{"feedback_varyings":null,"interface_block_bindings":[[0,"Skeleton0"],[4,"BindPose"]],"sampler_default_values":null,"shader_parameters":[["vertex","float","boneLength",0],["vertex","mat3x4","boneMatrices3x4",0],["vertex","vec4","boneMatrices",0],["vertex","vec4","f1Attributes",0],["vertex","vec4","f2Attributes",0],["vertex","float","interpolationParameter",1],["vertex","mat4","modelViewProjection",1],["vertex","mat3","pyramidRotation",1],["vertex","ivec2","startIndices",1],["vertex","float","thickness",1]],"vertex_attributes":null},"stages":{"fragment":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#ifdef FOG_OF_WAR_POSTPROCESS","#define DECLARE_FRAGCOLOR layout(location = 0) out vec4 outFragColor; layout(location = 2) out vec4 outFowBuffer;","#else","#define DECLARE_FRAGCOLOR layout(location = 0) out vec4 outFragColor;","#endif","#define outFragDepth gl_FragDepth","DECLARE_FRAGCOLOR","flat in vec3 color;","void main()","{","#ifdef OVERDRAW_FULL","outFragColor = vec4(0.1, 0.0, 0.0, 1.0);","#else","outFragColor = vec4(color, 1.0);","#ifdef FOG_OF_WAR_POSTPROCESS","outFowBuffer = vec4(1.0, 0.0, 0.0, 1.0);","#endif","#ifdef OVERDRAW_ALPHA","outFragColor = vec4(0.1, 0.0, 0.0, 1.0);","#endif","#endif","}"],"vertex":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#ifdef SSBO_SKELETON","#extension GL_ARB_shader_storage_buffer_object: require","#endif","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#ifndef MAX_BONES","#define MAX_BONES 1","#endif","void translate(inout mat4 m, in vec3 v)","{","m[0].xyz += m[0][3] * v;","m[1].xyz += m[1][3] * v;","m[2].xyz += m[2][3] * v;","m[3].xyz += m[3][3] * v;","}","void matrixScale(inout mat4 m, in float s)","{","m[0][0] *= s;","m[0][1] *= s;","m[0][2] *= s;","m[0][3] *= s;","m[1][0] *= s;","m[1][1] *= s;","m[1][2] *= s;","m[1][3] *= s;","m[2][0] *= s;","m[2][1] *= s;","m[2][2] *= s;","m[2][3] *= s;","}","mat3x4 mat34mul(in mat3x4 m1, in mat3x4 m2)","{","mat4 m = mat4(m2[0], m2[1], m2[2], vec4(0.0, 0.0, 0.0, 1.0)) * mat4(m1[0], m1[1], m1[2], vec4(0.0, 0.0, 0.0, 1.0));","return mat3x4(m[0], m[1], m[2]);","}","vec4 quaternionMultiply(in vec4 q1, in vec4 q2)","{","return vec4(cross(q1.xyz, q2.xyz) + q1.w * q2.xyz + q2.w * q1.xyz, q1.w * q2.w - dot(q1.xyz, q2.xyz));","}","mat4 quaternionMatrix4(in vec4 q)","{","float xx = 2.0 * q.x * q.x;","float yy = 2.0 * q.y * q.y;","float zz = 2.0 * q.z * q.z;","float xy = 2.0 * q.x * q.y;","float xz = 2.0 * q.x * q.z;","float yz = 2.0 * q.y * q.z;","float wx = 2.0 * q.w * q.x;","float wy = 2.0 * q.w * q.y;","float wz = 2.0 * q.w * q.z;","return mat4(","1.0 - yy - zz, xy + wz, xz - wy, 0.0,","xy - wz, 1.0 - xx - zz, yz + wx, 0.0,","xz + wy, yz - wx, 1.0 - xx - yy, 0.0,","0.0, 0.0, 0.0, 1.0",");","}","mat3 quaternionMatrix3(in vec4 q)","{","float xx = 2.0 * q.x * q.x;","float yy = 2.0 * q.y * q.y;","float zz = 2.0 * q.z * q.z;","float xy = 2.0 * q.x * q.y;","float xz = 2.0 * q.x * q.z;","float yz = 2.0 * q.y * q.z;","float wx = 2.0 * q.w * q.x;","float wy = 2.0 * q.w * q.y;","float wz = 2.0 * q.w * q.z;","return mat3(","1.0 - yy - zz, xy + wz, xz - wy,","xy - wz, 1.0 - xx - zz, yz + wx,","xz + wy, yz - wx, 1.0 - xx - yy",");","}","vec4 quaternionSlerp(in vec4 qa, in vec4 qb, in float t)","{","float cosHalfTheta = dot(qa, qb);","if (cosHalfTheta >= 0.999999f) return normalize(mix(qa, qb, t));","if (cosHalfTheta <= -0.999999f) return qa;","float halfTheta = acos(cosHalfTheta);","float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);","if (abs(sinHalfTheta) < 0.001) return normalize(mix(qa, qb, t));","float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;","float ratioB = sin(t * halfTheta) / sinHalfTheta;","return qa * ratioA + qb * ratioB;","}","#ifdef SSBO_SKELETON","uniform ivec2 startIndices;","#define matricesStartIndex startIndices.x","#define boneMatrixStartIndex startIndices.y","layout(std140, binding = 0) restrict readonly buffer BindInverse { mat3x4 bindInverseMatrices[]; };","mat3x4 getBindInverse(in int index) { return bindInverseMatrices[matricesStartIndex + index]; }","layout(std140, binding = 4) restrict readonly buffer BoneMatrices { mat3x4 boneMatrices[]; };","mat3x4 getBoneMatrix(in int idx) { return boneMatrices[boneMatrixStartIndex + idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices[boneMatrixStartIndex + idx - 1]; }","#elif defined(UBO_AVAILABLE)","layout(std140) uniform Skeleton0","{","mat3x4 boneMatrices[MAX_BONES];","};","mat3x4 getBoneMatrix(in int idx) { return boneMatrices[idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices[idx - 1]; }","layout(std140) uniform BindPose","{","mat3x4 bindInverse[MAX_BONES];","};","mat3x4 getBindInverse(in int index) { return bindInverse[index]; }","#elif defined(CPU_SKELETON)","uniform mat3x4 boneMatrices3x4[MAX_BONES];","mat3x4 getBoneMatrix(in int idx) { return boneMatrices3x4[idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices3x4[idx - 1]; }","#else","mat3x4 getBoneMatrix(in int idx) { return mat3x4(0.0); }","mat3x4 calcBoneMatrix(in int idx) { return mat3x4(0.0); }","#endif","#ifdef NEVER_DEFINED","uniform vec4 f1Attributes[MAX_BONES];","uniform vec4 f2Attributes[MAX_BONES];","uniform vec4 boneMatrices[MAX_BONES];","#endif","const vec4 pyramid[] = vec4[](","vec4(-0.5, -0.5, 0.0, 0.9),","vec4(0.5, 0.5, 0.0, 0.9),","vec4(0.5, -0.5, 0.0, 0.9),","vec4(-0.5, -0.5, 0.0, 0.9),","vec4(-0.5, 0.5, 0.0, 0.9),","vec4(0.5, 0.5, 0.0, 0.9),","vec4(-0.5, -0.5, 0.0, 0.95),","vec4(0.5, -0.5, 0.0, 0.95),","vec4(0.0, 0.0, 1.0, 0.95),","vec4(0.5, -0.5, 0.0, 0.65),","vec4(0.5, 0.5, 0.0, 0.65),","vec4(0.0, 0.0, 1.0, 0.65),","vec4(0.5, 0.5, 0.0, 0.95),","vec4(-0.5, 0.5, 0.0, 0.95),","vec4(0.0, 0.0, 1.0, 0.95),","vec4(-0.5, 0.5, 0.0, 0.65),","vec4(-0.5, -0.5, 0.0, 0.65),","vec4(0.0, 0.0, 1.0, 0.65)",");","uniform mat4 modelViewProjection;","uniform float interpolationParameter;","uniform float boneLength[MAX_BONES];","uniform float thickness;","uniform mat3 pyramidRotation;","#define BONE_COLOR vec3(1.0, 0.0, 0.0)","flat out vec3 color;","void main()","{","vec3 v;","int idx0 = gl_VertexID / 18;","vec4 pyramidVertex = pyramid[gl_VertexID % 18];","v = pyramidVertex.xyz;","color = BONE_COLOR * pyramidVertex.w;","int idx = idx0 + 1;","mat3x4 boneMatrix = calcBoneMatrix(idx);","v.xy *= thickness;","v.z *= (boneLength[idx0]);","v = pyramidRotation * v;","gl_Position = modelViewProjection * vec4(vec4(v, 1.0) * boneMatrix, 1.0);","}"]}}
