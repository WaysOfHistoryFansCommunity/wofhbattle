{"meta":{"feedback_varyings":null,"interface_block_bindings":[[0,"Skeleton0"],[4,"BindPose"],[5,"Skeleton5"]],"sampler_default_values":[["diffuseTex",0],["dissolveColorTex",3],["dissolveHoleTex",5],["emissionTex",8],["fogOfWar",6],["maskTex",9],["metalnessMap",4],["normalMap",2],["shadowTex",7],["specularRoughnessTex",1],["translucencyTex",10]],"shader_parameters":[["vertex","float","attachmentBoneIndex",1],["vertex","vec4","attachmentDisplacementScale",1],["vertex","mat3x4","attachmentMatrix",1],["fragment","bvec2","b2params",1],["vertex","mat3x4","boneMatrices3x4",0],["fragment","vec3","cameraPosition",1],["vertex","vec3","cameraPosition",1],["fragment","vec4","darkColorInvMaxSpecular",1],["fragment","sampler2D","diffuseTex",1],["fragment","vec4","dissolveColorFactorThreshold",1],["fragment","sampler2D","dissolveColorTex",1],["fragment","sampler2D","dissolveHoleTex",1],["fragment","sampler2D","emissionTex",1],["fragment","vec4","fogColor",1],["fragment","vec2","fogNearFar",1],["fragment","sampler2D","fogOfWar",1],["fragment","float","fowInterpolationParameter",1],["vertex","vec4","fowMapScalePosition",1],["vertex","int","geometryType",1],["vertex","bool","hasNormalMap",1],["fragment","int","instanceIdx",1],["vertex","int","instanceIdx",1],["vertex","float","interpolationParameter",1],["fragment","vec3","lightColor",1],["fragment","vec3","lightDirection",1],["fragment","sampler2D","maskTex",1],["fragment","sampler2D","metalnessMap",1],["fragment","float","normalMapZScale",1],["fragment","sampler2D","normalMap",1],["fragment","vec4","occlusionColor",1],["fragment","vec2","shadowBiasScaleMax",1],["fragment","vec4","shadowMapSize",1],["fragment","sampler2D","shadowTex",1],["fragment","sampler2D","specularRoughnessTex",1],["vertex","ivec2","startIndices",1],["fragment","vec2","submarineBottomDiff",1],["fragment","vec3","submarineColorMultiplier",1],["fragment","float","sunFarFadeFactor",1],["vertex","mat4","sunMatrix",1],["fragment","sampler2D","translucencyTex",1],["fragment","vec4","v4params",7],["vertex","vec4","v4params",7],["vertex","mat4","viewProjection",1]],"vertex_attributes":[[0,"vec3","vertexAttribute0"],[1,"vec4","vertexAttribute1"],[2,"vec3","vertexAttribute2"],[3,"vec3","vertexAttribute3"],[6,"vec3","vertexAttribute6"],[7,"vec3","vertexAttribute7"],[10,"vec2","texCoord"],[11,"uvec2","vertexAttribute11"]]},"stages":{"fragment":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#ifdef BATCHED","#extension GL_ARB_bindless_texture: require","#endif","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","vec3 unpackRgNormal(in vec2 xy)","{","xy = xy * 2.0 - 1.0;","return vec3(xy, sqrt(max(0.0, 1.0 - dot(xy, xy))));","}","vec3 sampleNormalmap(in sampler2D tex, in vec2 tc)","{","return unpackRgNormal(SAMPLE_2D(tex, tc).NM_XY);","}","vec3 downsample13(in sampler2D tex, in vec2 tc, in vec2 texelSize)","{","vec3 s1  = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0, -1.0)).rgb;","vec3 s2  = SAMPLE_2D(tex, tc + texelSize * vec2( 0.0, -1.0)).rgb;","vec3 s3  = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0, -1.0)).rgb;","vec3 s4  = SAMPLE_2D(tex, tc + texelSize * vec2(-0.5, -0.5)).rgb;","vec3 s5  = SAMPLE_2D(tex, tc + texelSize * vec2( 0.5, -0.5)).rgb;","vec3 s6  = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0,  0.0)).rgb;","vec3 s7  = SAMPLE_2D(tex, tc).rgb;","vec3 s8  = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0,  0.0)).rgb;","vec3 s9  = SAMPLE_2D(tex, tc + texelSize * vec2(-0.5,  0.5)).rgb;","vec3 s10 = SAMPLE_2D(tex, tc + texelSize * vec2( 0.5,  0.5)).rgb;","vec3 s11 = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0,  1.0)).rgb;","vec3 s12 = SAMPLE_2D(tex, tc + texelSize * vec2( 0.0,  1.0)).rgb;","vec3 s13 = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0,  1.0)).rgb;","return","(s4 + s5 + s9 + s10) * 0.125 +","(s1 + s2 + s7 + s6) * 0.03125 +","(s2 + s3 + s8 + s7) * 0.03125 +","(s6 + s7 + s12 + s11) * 0.03125 +","(s7 + s8 + s13 + s12) * 0.03125;","}","vec3 downsample4(in sampler2D tex, in vec2 tc, in vec2 texelSize)","{","vec4 displacement = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);","vec3 s =","SAMPLE_2D(tex, tc + displacement.xy).rgb +","SAMPLE_2D(tex, tc + displacement.zy).rgb +","SAMPLE_2D(tex, tc + displacement.xw).rgb +","SAMPLE_2D(tex, tc + displacement.zw).rgb;","return s * 0.25;","}","vec3 magTent(in sampler2D tex, in vec2 uv, in vec2 texelSize, in float sampleScale)","{","vec4 displacement = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;","vec3 result =","SAMPLE_2D(tex, uv - displacement.xy).rgb +","SAMPLE_2D(tex, uv - displacement.wy).rgb * 2.0 +","SAMPLE_2D(tex, uv - displacement.zy).rgb +","SAMPLE_2D(tex, uv + displacement.zw).rgb * 2.0 +","SAMPLE_2D(tex, uv).rgb * 4.0 +","SAMPLE_2D(tex, uv + displacement.xw).rgb * 2.0 +","SAMPLE_2D(tex, uv + displacement.zy).rgb +","SAMPLE_2D(tex, uv + displacement.wy).rgb * 2.0 +","SAMPLE_2D(tex, uv + displacement.xy).rgb;","return result * 0.0625;","}","vec3 magBox(in sampler2D tex, in vec2 tc, in vec2 texelSize, in float sampleScale)","{","vec4 displacement = texelSize.xyxy * vec4(-0.5, -0.5, 0.5, 0.5) * sampleScale;","vec3 s =","SAMPLE_2D(tex, (tc + displacement.xy)).rgb +","SAMPLE_2D(tex, (tc + displacement.zy)).rgb +","SAMPLE_2D(tex, (tc + displacement.xw)).rgb +","SAMPLE_2D(tex, (tc + displacement.zw)).rgb;","return s * 0.25;","}","#ifdef FOG","uniform vec2 fogNearFar;","uniform vec4 fogColor;","float getFogFactor(in float zEye)","{","float fogNear = fogNearFar[0];","float fogFar = fogNearFar[1];","return clamp((zEye - fogNear) / (fogFar - fogNear), 0.0, 1.0) * fogColor.a;","}","vec3 addFogFactor(in vec3 color, in float fogFactor)","{","return mix(color, fogColor.rgb, fogFactor);","}","vec3 addFog(in vec3 color, in float zEye)","{","float fogFactor = getFogFactor(zEye);","return addFogFactor(color, fogFactor);","}","#else","float getFogFactor(in float zEye)","{","return 0.0;","}","vec3 addFogFactor(in vec3 color, in float fogFactor)","{","return color;","}","vec3 addFog(in vec3 color, in float zEye)","{","return color;","}","#endif","#ifdef FOG_OF_WAR","uniform sampler2D fogOfWar ;","uniform float fowInterpolationParameter;","float getFogOfWarFactor(in vec2 tc)","{","const float border0 = -0.001;","const float border1 = 1.001;","float clampTo0 = step(border0, tc.x) * (1.0 - step(border1, tc.x)) * step(border0, tc.y) * (1.0 - step(border1, tc.y));","vec2 rg = texture(fogOfWar, tc).rg * clampTo0;","return mix(rg.r, rg.g, fowInterpolationParameter);","}","#else","float getFogOfWarFactor(in vec2 tc) { return 1.0; }","#endif","float istep(float edge, float x)","{","return step(x, edge);","}","float plate(float edge1, float edge2, float x)","{","return step(edge1, x) * step(x, edge2);","}","float textureBorder1(sampler2D s, vec2 uv)","{","float inTexture = plate(0.0, 1.0, uv.x) * plate(0.0, 1.0, uv.y);","return inTexture * texture(s, uv).r + (1.0 - inTexture);","}","float textureCompare(sampler2D depth, vec2 uv, float zReceiver, float bias)","{","float shadowDepth = textureBorder1(depth, uv);","if (((shadowDepth + bias) < zReceiver) && (zReceiver <= 1.0)) return 1.0;","return 0.0;","}","uniform float sunFarFadeFactor;","float farShadowFade(in float uvy)","{","return (1.0 - smoothstep(sunFarFadeFactor, 1.0, uvy));","}","uniform vec2 shadowBiasScaleMax;","float shadowBias(vec3 normal, vec3 toSun)","{","return max(shadowBiasScaleMax.x * (1.0 - dot(normal, toSun)), shadowBiasScaleMax.y);","}","#if defined(SHADOWED_PCSS)","#define BLOCKER_SEARCH_NUM_SAMPLES 16","#define PCF_NUM_SAMPLES 64","#define LIGHT_SIZE_UV 0.01","#define NEAR_PLANE 1.0","float PenumbraSize(float zReceiver, float zBlocker)","{","return (zReceiver - zBlocker) / zBlocker;","}","float PCF_Filter(sampler2D depth, vec2 uv, float zReceiver, float filterRadiusUV, float bias)","{","vec2 poissonDisk[64];","poissonDisk[0] = vec2(-0.613392, 0.617481);","poissonDisk[1] = vec2(0.170019, -0.040254);","poissonDisk[2] = vec2(-0.299417, 0.791925);","poissonDisk[3] = vec2(0.645680, 0.493210);","poissonDisk[4] = vec2(-0.651784, 0.717887);","poissonDisk[5] = vec2(0.421003, 0.027070);","poissonDisk[6] = vec2(-0.817194, -0.271096);","poissonDisk[7] = vec2(-0.705374, -0.668203);","poissonDisk[8] = vec2(0.977050, -0.108615);","poissonDisk[9] = vec2(0.063326, 0.142369);","poissonDisk[10] = vec2(0.203528, 0.214331);","poissonDisk[11] = vec2(-0.667531, 0.326090);","poissonDisk[12] = vec2(-0.098422, -0.295755);","poissonDisk[13] = vec2(-0.885922, 0.215369);","poissonDisk[14] = vec2(0.566637, 0.605213);","poissonDisk[15] = vec2(0.039766, -0.396100);","poissonDisk[16] = vec2(0.751946, 0.453352);","poissonDisk[17] = vec2(0.078707, -0.715323);","poissonDisk[18] = vec2(-0.075838, -0.529344);","poissonDisk[19] = vec2(0.724479, -0.580798);","poissonDisk[20] = vec2(0.222999, -0.215125);","poissonDisk[21] = vec2(-0.467574, -0.405438);","poissonDisk[22] = vec2(-0.248268, -0.814753);","poissonDisk[23] = vec2(0.354411, -0.887570);","poissonDisk[24] = vec2(0.175817, 0.382366);","poissonDisk[25] = vec2(0.487472, -0.063082);","poissonDisk[26] = vec2(-0.084078, 0.898312);","poissonDisk[27] = vec2(0.488876, -0.783441);","poissonDisk[28] = vec2(0.470016, 0.217933);","poissonDisk[29] = vec2(-0.696890, -0.549791);","poissonDisk[30] = vec2(-0.149693, 0.605762);","poissonDisk[31] = vec2(0.034211, 0.979980);","poissonDisk[32] = vec2(0.503098, -0.308878);","poissonDisk[33] = vec2(-0.016205, -0.872921);","poissonDisk[34] = vec2(0.385784, -0.393902);","poissonDisk[35] = vec2(-0.146886, -0.859249);","poissonDisk[36] = vec2(0.643361, 0.164098);","poissonDisk[37] = vec2(0.634388, -0.049471);","poissonDisk[38] = vec2(-0.688894, 0.007843);","poissonDisk[39] = vec2(0.464034, -0.188818);","poissonDisk[40] = vec2(-0.440840, 0.137486);","poissonDisk[41] = vec2(0.364483, 0.511704);","poissonDisk[42] = vec2(0.034028, 0.325968);","poissonDisk[43] = vec2(0.099094, -0.308023);","poissonDisk[44] = vec2(0.693960, -0.366253);","poissonDisk[45] = vec2(0.678884, -0.204688);","poissonDisk[46] = vec2(0.001801, 0.780328);","poissonDisk[47] = vec2(0.145177, -0.898984);","poissonDisk[48] = vec2(0.062655, -0.611866);","poissonDisk[49] = vec2(0.315226, -0.604297);","poissonDisk[50] = vec2(-0.780145, 0.486251);","poissonDisk[51] = vec2(-0.371868, 0.882138);","poissonDisk[52] = vec2(0.200476, 0.494430);","poissonDisk[53] = vec2(-0.494552, -0.711051);","poissonDisk[54] = vec2(0.612476, 0.705252);","poissonDisk[55] = vec2(-0.578845, -0.768792);","poissonDisk[56] = vec2(-0.772454, -0.090976);","poissonDisk[57] = vec2(0.504440, 0.372295);","poissonDisk[58] = vec2(0.155736, 0.065157);","poissonDisk[59] = vec2(0.391522, 0.849605);","poissonDisk[60] = vec2(-0.620106, -0.328104);","poissonDisk[61] = vec2(0.789239, -0.419965);","poissonDisk[62] = vec2(-0.545396, 0.538133);","poissonDisk[63] = vec2(-0.178564, -0.596057);","float sum = 0.0;","for ( int i = 0; i < PCF_NUM_SAMPLES; ++i )","{","vec2 offset = poissonDisk[i] * filterRadiusUV;","sum += textureCompare(depth, uv + offset, zReceiver, bias);","}","return sum / float(PCF_NUM_SAMPLES);","}","vec2 FindBlocker(sampler2D depth, vec2 uv, float zReceiver, float bias)","{","vec2 poissonDisk[16];","poissonDisk[0] = vec2 ( -0.94201624, -0.39906216 );","poissonDisk[1] = vec2 ( 0.94558609, -0.76890725 );","poissonDisk[2] = vec2 ( -0.094184101, -0.92938870 );","poissonDisk[3] = vec2 ( 0.34495938, 0.29387760 );","poissonDisk[4] = vec2 ( -0.91588581, 0.45771432 );","poissonDisk[5] = vec2 ( -0.81544232, -0.87912464 );","poissonDisk[6] = vec2 ( -0.38277543, 0.27676845 );","poissonDisk[7] = vec2 ( 0.97484398, 0.75648379 );","poissonDisk[8] = vec2 ( 0.44323325, -0.97511554 );","poissonDisk[9] = vec2 ( 0.53742981, -0.47373420 );","poissonDisk[10] = vec2 ( -0.26496911, -0.41893023 );","poissonDisk[11] = vec2 ( 0.79197514, 0.19090188 );","poissonDisk[12] = vec2 ( -0.24188840, 0.99706507 );","poissonDisk[13] = vec2 ( -0.81409955, 0.91437590 );","poissonDisk[14] = vec2 ( 0.19984126, 0.78641367 );","poissonDisk[15] = vec2 ( 0.14383161, -0.14100790 );","float avgBlockerDepth = 0.0;","float numBlockers = 0.0;","float searchWidth = LIGHT_SIZE_UV * (zReceiver - float(NEAR_PLANE)) / zReceiver;","float blockerSum = 0.0;","for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; ++i) {","vec2 uvDisplaced = uv + poissonDisk[i] * searchWidth;","float shadowMapDepth = textureBorder1(depth, uvDisplaced);","if (((shadowMapDepth + bias) < zReceiver) && !(zReceiver > 1.0)) {","blockerSum += shadowMapDepth;","numBlockers++;","}","}","avgBlockerDepth = blockerSum / numBlockers;","return vec2(avgBlockerDepth, numBlockers);","}","float getShadow(in sampler2D depth, in vec2 uv, in float zReceiver, in float bias, in int cascadeId)","{","vec2 fb = FindBlocker(depth, uv, zReceiver, bias);","float avgBlockerDepth = fb.x;","float numBlockers = fb.y;","if( numBlockers < 1.0 ) return 0.0;","float penumbraRatio = PenumbraSize(zReceiver, avgBlockerDepth);","float filterRadiusUV = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;","float shadowValue = (PCF_Filter(depth, uv, zReceiver, filterRadiusUV, bias));","return shadowValue * farShadowFade(uv.y);","}","#elif defined(SHADOWED_PCF)","uniform vec4 shadowMapSize;","float textureShadowLerp(in sampler2D depths, in vec2 uv, in float zReceiver, in float bias)","{","vec2 texelSize = shadowMapSize.zw;","vec2 centroidUV;","vec2 f = modf(uv * shadowMapSize.xy, centroidUV);","centroidUV *= texelSize;","float lb = textureCompare(depths, centroidUV + texelSize * vec2(0.0, 0.0), zReceiver, bias);","float lt = textureCompare(depths, centroidUV + texelSize * vec2(0.0, 1.0), zReceiver, bias);","float rb = textureCompare(depths, centroidUV + texelSize * vec2(1.0, 0.0), zReceiver, bias);","float rt = textureCompare(depths, centroidUV + texelSize * vec2(1.0, 1.0), zReceiver, bias);","float a = mix(lb, lt, f.y);","float b = mix(rb, rt, f.y);","float c = mix(a, b, f.x);","return c;","}","#ifndef CSM_COUNT","#define CSM_COUNT 1","#endif","float getShadow(in sampler2D depth, in vec2 uv, in float zReceiver, in float bias, in int cascadeId)","{","#if CSM_COUNT > 1","uv.x *= 0.25;","uv.x += 0.25 * float(cascadeId);","#endif","vec2 texelSize = shadowMapSize.zw;","float shadow = 0.0;","for (int x = -1; x <= 1; ++x) {","for (int y = -1; y <= 1; ++y) {","vec2 uv1 = uv + vec2(x, y) * texelSize;","shadow += textureShadowLerp(depth, uv1, zReceiver, bias);","}","}","return (shadow / float(9.0)) * farShadowFade(uv.y);","}","#elif defined(SHADOWED_PLAIN)","float getShadow(in sampler2D depth, in vec2 uv, in float zReceiver, in float bias, in int cascadeId)","{","return textureCompare(depth, uv, zReceiver, bias) * farShadowFade(uv.y);","}","#else","float getShadow(sampler2D depth, vec2 uv, float zReceiver, float bias) { return 0.0; }","#endif","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","uniform sampler2D shadowTex ;","float getBiasedShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in int cascadeId)","{","float bias = shadowBias(normal, lightDirection);","vec3 smc = (sunVertexPosition + vec3(1.0, 1.0, 1.0)) * 0.5;","return getShadow(shadowTex, smc.xy, smc.z, bias, cascadeId);","}","float getWaterBiasedShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in float distortionFactor)","{","vec3 shadowMapCoord = (sunVertexPosition.xyz + vec3(1.0, 1.0, 1.0)) * 0.5;","float bias = shadowBias(normal, lightDirection);","vec2 tc = shadowMapCoord.xy + normal.xy * distortionFactor * 0.1;","return getShadow(shadowTex, tc, shadowMapCoord.z, bias, 0 );","}","void addShadowSpec(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor, inout vec3 totalSpecular)","{","float shadow = getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","sunColor = mix(sunColor, darkColor, shadow);","totalSpecular *= 1.0 - shadow;","}","void addShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor)","{","float shadow = getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","sunColor = mix(sunColor, darkColor, shadow);","}","#else","void addShadowSpec(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor, inout vec3 totalSpecular) {}","void addShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor) {}","#endif","#define PI 3.14159265359","float DistributionGGX(vec3 N, vec3 H, float roughness)","{","float a      = roughness*roughness;","float a2     = a*a;","float NdotH  = max(dot(N, H), 0.0);","float NdotH2 = NdotH*NdotH;","float num   = a2;","float denom = (NdotH2 * (a2 - 1.0) + 1.0);","denom = PI * denom * denom;","return num / max(denom, 0.0000001);","}","float GeometrySchlickGGX(float NdotV, float roughness)","{","float r = (roughness + 1.0);","float k = (r*r) / 8.0;","float num   = NdotV;","float denom = NdotV * (1.0 - k) + k;","return num / denom;","}","float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)","{","float NdotV = max(dot(N, V), 0.0);","float NdotL = max(dot(N, L), 0.0);","float ggx2  = GeometrySchlickGGX(NdotV, roughness);","float ggx1  = GeometrySchlickGGX(NdotL, roughness);","return ggx1 * ggx2;","}","vec3 fresnelSchlick(float cosTheta, vec3 F0)","{","float invCosTheta = 1.0 - cosTheta;","float pow5 = invCosTheta * invCosTheta * invCosTheta * invCosTheta * invCosTheta;","return F0 + (1.0 - F0) * pow5;","}","vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)","{","float invCosTheta = 1.0 - cosTheta;","float pow5 = invCosTheta * invCosTheta * invCosTheta * invCosTheta * invCosTheta;","return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow5;","}","vec3 metallicPbrColor(","in float roughness,","in float metallic,","in float translucency,","in vec3 albedo,","in vec3 lightColor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal",")","{","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = dot(normal, lightDirection);","NdotL = mix(max(NdotL, 0.0), abs(NdotL), translucency);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec\t\t  = numerator / max(denominator, 0.000001);","return (kD * albedo / PI + spec) * lightColor * NdotL;","}","vec3 metallicPbrSunColor(","in float roughness,","in float metallic,","in float translucency,","in float emission,","in vec3 albedo,","in vec3 darkColor,","in vec3 lightColor,","in vec3 envmapSunFactor,","in vec3 envmapShadowFactor,","in vec3 envmapSpecularFactor,","in vec3 sunSpecularFactor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in sampler2D specularBrdfLut,","in samplerCube irradianceMap,","in samplerCube envMap,","in int cascadeId",")","{","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","float shadowFactor = 1.0 - getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","#else","float shadowFactor = 1.0;","#endif","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = dot(normal, lightDirection);","NdotL = mix(max(NdotL, 0.0), abs(NdotL), translucency);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec = numerator / max(denominator, 0.000001);","spec *= sunSpecularFactor * shadowFactor;","vec3 dimLightColor = lightColor * NdotL * shadowFactor;","vec3 diffuseColor = kD * albedo / PI;","vec3 Lo = diffuseColor * max(0.0, 1.0 - emission) * dimLightColor + albedo * emission + spec * dimLightColor;","F = fresnelSchlickRoughness(max(dot(normal, viewDirection), 0.0), F0, roughness);","kD = 1.0 - F;","kD *= 1.0 - metallic;","vec3 irradianceSampleDir = normal.xzy;","irradianceSampleDir.z = -irradianceSampleDir.z;","vec3 irradiance = texture(irradianceMap, irradianceSampleDir).rgb * mix(envmapShadowFactor, envmapSunFactor, NdotL * shadowFactor);","vec3 diffuse = irradiance * albedo;","const float MAX_REFLECTION_LOD = 4.0;","vec3 R = reflect(-viewDirection, normal);","R = R.xzy;","R.z = -R.z;","vec3 prefilteredColor = textureLod(envMap, R,  roughness * MAX_REFLECTION_LOD).rgb;","vec2 brdf  = texture(specularBrdfLut, vec2(max(dot(normal, viewDirection), 0.0), roughness)).rg;","vec3 specular = prefilteredColor * (F * brdf.x + brdf.y) * shadowFactor * envmapSpecularFactor;","vec3 ambient = kD * diffuse + specular;","return Lo + ambient;","}","vec3 waterPbrSunColor(","in float roughness,","in float metallic,","in float specularFactor,","in float distortionFactor,","in vec3 albedo,","in vec3 lightColor,","in vec3 darkColor,","in vec3 envmapSunFactor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in sampler2D specularBrdfLut,","in samplerCube irradianceMap,","in vec3 reflectionColor)","{","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","float shadowFactor = 1.0 - getWaterBiasedShadow(normal, sunVertexPosition, lightDirection, distortionFactor);","#else","float shadowFactor = 1.0;","#endif","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = max(dot(normal, lightDirection), 0.0);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec = numerator / max(denominator, 0.000001);","spec *= shadowFactor * specularFactor;","vec3 dimLightColor = lightColor * NdotL * shadowFactor;","vec3 diffuseColor = kD * albedo / PI;","vec3 Lo = diffuseColor * dimLightColor + spec * dimLightColor;","F = fresnelSchlickRoughness(max(dot(normal, viewDirection), 0.0), F0, roughness);","kD = 1.0 - F;","kD *= 1.0 - metallic;","vec3 irradianceSampleDir = normal.xzy;","irradianceSampleDir.z = -irradianceSampleDir.z;","vec3 irradiance = texture(irradianceMap, irradianceSampleDir).rgb * mix(darkColor, envmapSunFactor, NdotL * shadowFactor);","vec3 diffuse = irradiance * albedo;","const float MAX_REFLECTION_LOD = 4.0;","vec3 R = reflect(-viewDirection, normal);","R = R.xzy;","R.z = -R.z;","vec3 prefilteredColor = reflectionColor;","vec2 brdf  = texture(specularBrdfLut, vec2(max(dot(normal, viewDirection), 0.0), roughness)).rg;","vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);","specular = mix(specular * darkColor, specular, shadowFactor) * albedo;","vec3 ambient = kD * diffuse + specular;","return Lo + ambient;","}","vec3 blinnPhongColor(","in float specular,","in float specularPower,","in float translucency,","in float emission,","in vec3 albedo,","in vec3 darkColor,","in vec3 lightColor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in int cascadeId",")","{","vec3 reflection = -reflect(lightDirection, normal);","float fRdotV = max(0.0, dot(normalize(reflection), viewDirection));","vec3 totalSpecular = lightColor * pow(fRdotV, specularPower) * specular;","float LDdotN = dot(lightDirection, normal);","float lightIntensity = clamp(mix(max(LDdotN, 0.0), abs(LDdotN), translucency), 0.0, 1.0);","vec3 sunColor = mix(darkColor, lightColor, lightIntensity);","addShadowSpec(normal, sunVertexPosition, lightDirection, darkColor, cascadeId, sunColor, totalSpecular);","vec3 outDiffuseColor = albedo * sunColor;","outDiffuseColor = outDiffuseColor * max(0.0, 1.0 - emission) + albedo * emission;","return outDiffuseColor + totalSpecular;","}","#ifdef BATCHED","struct InstancingBuffer","{","vec4 maskColorEmissionFactor;","vec4 texDisplacementDissolveParams;","vec4 colorFactorNormalMapZScale;","vec4 occlusionColor;","vec4 dissolveColorFactorRange;","uvec4 diffuseNormalMap;","uvec4 specularRoughnessMetalnessMap;","uvec4 dissolveColorEmissionMap;","uvec4 maskTranslucencyMap;","};","uniform int instanceIdx;","layout(std140, binding = 7) restrict readonly buffer InstancesFrag { InstancingBuffer instances[]; };","flat in ivec2 instancingVaryingData;","#define instanceId instancingVaryingData.x","#define diffuseTex sampler2D(instances[instanceIdx + instanceId].diffuseNormalMap.xy)","#define normalMap sampler2D(instances[instanceIdx + instanceId].diffuseNormalMap.zw)","#define specularRoughnessTex sampler2D(instances[instanceIdx + instanceId].specularRoughnessMetalnessMap.xy)","#define metalnessMap sampler2D(instances[instanceIdx + instanceId].specularRoughnessMetalnessMap.zw)","#define dissolveColorTex sampler2D(instances[instanceIdx + instanceId].dissolveColorEmissionMap.xy)","#define emissionTex sampler2D(instances[instanceIdx + instanceId].dissolveColorEmissionMap.zw)","#define maskTex sampler2D(instances[instanceIdx + instanceId].maskTranslucencyMap.xy)","#define translucencyTex sampler2D(instances[instanceIdx + instanceId].maskTranslucencyMap.zw)","#define hasNormalMap (bool(instancingVaryingData.y))","#define maskColor (instances[instanceIdx + instanceId].maskColorEmissionFactor.rgb)","#define emissionFactor (instances[instanceIdx + instanceId].maskColorEmissionFactor.a)","#define colorFactor (instances[instanceIdx + instanceId].colorFactorNormalMapZScale.xyz)","#define normalMapZScale (instances[instanceIdx + instanceId].colorFactorNormalMapZScale.w)","#define texDisplacement (instances[instanceIdx + instanceId].texDisplacementDissolveParams.xy)","#define dissolveThreshold (instances[instanceIdx + instanceId].texDisplacementDissolveParams.z)","#define dissolveEnabled (bool(instances[instanceIdx + instanceId].texDisplacementDissolveParams.w == 1.0))","#define occlusionColor (instances[instanceIdx + instanceId].occlusionColor)","#define dissolveColorFactor (instances[instanceIdx + instanceId].dissolveColorFactorRange.rgb)","#define dissolveRange (instances[instanceIdx + instanceId].dissolveColorFactorRange.w)","#define specularPower 10.0","#define specularFactor 1.0","#endif","uniform sampler2D dissolveHoleTex ;","uniform vec3 lightColor;","#ifndef BATCHED","uniform sampler2D diffuseTex ;","uniform sampler2D specularRoughnessTex ;","uniform sampler2D normalMap ;","uniform sampler2D dissolveColorTex ;","#ifdef PBR_METALLIC","uniform sampler2D metalnessMap ;","#endif","uniform sampler2D emissionTex ;","uniform sampler2D maskTex ;","uniform sampler2D translucencyTex ;","uniform vec4 dissolveColorFactorThreshold;","uniform vec4 occlusionColor;","uniform float normalMapZScale;","uniform bvec2 b2params;","#define hasNormalMap b2params.x","#define dissolveEnabled b2params.y","uniform vec4 v4params[7];","#define maskColorEmissionFactor v4params[0]","#define texDisplacementSpecularPowerFactor v4params[1]","#define colorFactorDissolveRange v4params[2]","#define texDisplacement texDisplacementSpecularPowerFactor.xy","#define specularPower texDisplacementSpecularPowerFactor.z","#define specularFactor texDisplacementSpecularPowerFactor.w","#define dissolveThreshold dissolveColorFactorThreshold.a","#define dissolveColorFactor dissolveColorFactorThreshold.rgb","#define colorFactor colorFactorDissolveRange.rgb","#define dissolveRange colorFactorDissolveRange.a","#define maskColor maskColorEmissionFactor.rgb","#define emissionFactor maskColorEmissionFactor.a","#endif","#ifndef DEFERRED","uniform vec3 lightDirection;","#endif","uniform vec3 cameraPosition;","uniform vec4 darkColorInvMaxSpecular;","uniform vec3 submarineColorMultiplier;","uniform vec2 submarineBottomDiff;","#define submarineBottom (submarineBottomDiff.x)","#define submarineDiff (submarineBottomDiff.y)","#define darkColor darkColorInvMaxSpecular.xyz","smooth in vec3 fragNormal;","smooth in vec4 fragTexCoordWorldVertexPositionXy;","smooth in vec3 fragInterpolatedVertex;","#ifndef DEFERRED","smooth in vec3 sunVertexPosition;","#endif","#define fragTexCoord (fragTexCoordWorldVertexPositionXy.xy)","#define worldVertexPositionXy (fragTexCoordWorldVertexPositionXy.zw)","float dissolve()","{","float dissolve = texture(dissolveHoleTex, fragTexCoord).r;","float aboveThreshold = step(dissolveThreshold, dissolve);","if (aboveThreshold == 0.0) discard;","float colorize = smoothstep(dissolveThreshold, min(dissolveThreshold + dissolveRange, 1.0), dissolve);","return colorize;","}","layout(location = 0) out vec4 drawBuffer0;","layout(location = 1) out vec4 drawBuffer1;","#ifdef DEFERRED","layout(location = 2) out vec4 drawBuffer2;","layout(location = 3) out vec4 drawBuffer3;","#define albedo drawBuffer0.rgb","#define outFragNormal drawBuffer2.rgb","#define outSpecular drawBuffer3.r","#define outRoughness drawBuffer3.r","#define outEmission drawBuffer3.g","#define outSpecularPower drawBuffer3.b","#define outMetalness drawBuffer3.b","#define outTranslucency drawBuffer3.a","#else","#ifdef FOG_OF_WAR_POSTPROCESS","layout(location = 2) out vec4 drawBuffer2;","#define outFowBuffer drawBuffer2","#endif","#endif","#define outOcclusionColor drawBuffer1","#define outFragColor drawBuffer0","#define specularPowerScale 100.0","mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv)","{","vec3 dp1 = dFdx(p);","vec3 dp2 = dFdy(p);","vec2 duv1 = dFdx(uv);","vec2 duv2 = dFdy(uv);","vec3 dp2perp = cross(dp2, N);","vec3 dp1perp = cross(N, dp1);","vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;","vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;","float invmax = inversesqrt(max(dot(T,T), dot(B,B)));","return mat3(T * invmax, B * invmax, N);","}","vec3 perturbNormal(in vec3 N, in vec3 V, in vec2 texcoord)","{","vec3 tn = sampleNormalmap(normalMap, texcoord);","tn.y = -tn.y;","tn.z *= normalMapZScale;","mat3 TBN = cotangentFrame(N, -V, texcoord);","return normalize(TBN * tn);","}","void main()","{","#ifdef OVERDRAW_FULL","outFragColor = vec4(0.1, 0.0, 0.0, 1.0);","#else","vec2 displacedTexCoord = fragTexCoord + texDisplacement;","vec4 diffuseColor = texture(diffuseTex, displacedTexCoord);","float d = 1.0;","if (dissolveEnabled) d = dissolve();","if (diffuseColor.a < 0.5) discard;","#if !defined(PBR_METALLIC)","float specular = texture(specularRoughnessTex, displacedTexCoord).r * specularFactor;","#endif","float emission = texture(emissionTex, displacedTexCoord).r * emissionFactor;","float mask = texture(maskTex, displacedTexCoord).r;","float translucency = texture(translucencyTex, displacedTexCoord).r;","float submarineColorInterp = clamp((fragInterpolatedVertex.z - submarineBottom) / submarineDiff, 0.0, 1.0);","diffuseColor.xyz = mix(diffuseColor.xyz, maskColor, mask) * colorFactor * mix(submarineColorMultiplier, vec3(1.0), submarineColorInterp);","vec3 posToCam = cameraPosition - fragInterpolatedVertex;","float posToCamDistance = length(posToCam);","vec3 normal = normalize(fragNormal);","if (hasNormalMap) normal = perturbNormal(normal, posToCam, displacedTexCoord);","outOcclusionColor = occlusionColor;","if (!gl_FrontFacing) normal = -normal;","if (dissolveEnabled) {","vec3 edgeColor = texture(dissolveColorTex, fragTexCoord).xyz * dissolveColorFactor;","diffuseColor.xyz = mix(edgeColor, diffuseColor.xyz, d);","}","float fow = getFogOfWarFactor(worldVertexPositionXy);","float fogFactor = getFogFactor(posToCamDistance);","outOcclusionColor *= fow;","outOcclusionColor.a *= 1.0 - fogFactor;","#ifdef DEFERRED","albedo = diffuseColor.xyz;","normal += vec3(1.0);","normal *= 0.5f;","outFragNormal = normal;","outEmission = 1.0 / (1.0 + emission);","outTranslucency = translucency;","#ifdef PBR_METALLIC","outMetalness = texture(metalnessMap, displacedTexCoord).r;","outRoughness = texture(specularRoughnessTex, displacedTexCoord).r;","#else","outSpecular = 1.0 / (1.0 + specular);","outSpecularPower = specularPower;","#endif","#else","vec3 viewDirection = posToCam / posToCamDistance;","#ifdef PBR_METALLIC","float metallic = texture(metalnessMap, displacedTexCoord).r;","float roughness = texture(specularRoughnessTex, displacedTexCoord).r;","outFragColor.rgb = metallicPbrColor(roughness, metallic, translucency, diffuseColor.xyz, lightColor, viewDirection, lightDirection, normal);","#else","outFragColor.rgb = blinnPhongColor(specular, specularPower * specularPowerScale, translucency, emission, diffuseColor.xyz, darkColor, lightColor, viewDirection, lightDirection, normal, sunVertexPosition, 0 );","#endif","outFragColor.a = 1.0;","outFragColor.rgb = addFogFactor(outFragColor.rgb, fogFactor);","outFragColor.rgb *= fow;","#ifdef FOG_OF_WAR_POSTPROCESS","outFowBuffer.r = fow;","#endif","#endif","#ifdef OVERDRAW_ALPHA","outFragColor = vec4(0.1, 0.0, 0.0, 1.0);","#endif","#endif","}"],"vertex":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#ifdef SSBO_SKELETON","#extension GL_ARB_shader_storage_buffer_object: require","#endif","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#ifndef MAX_BONES","#define MAX_BONES 1","#endif","#ifdef BATCHED","struct InstancingBuffer","{","ivec4 startIndices;","mat4 modelTransformation;","};","uniform int instanceIdx;","layout(std140, row_major, binding = 6) restrict readonly buffer Instances { InstancingBuffer instances[]; };","flat out ivec2 instancingVaryingData;","#define instanceId instancingVaryingData.x","#define attachmentBoneIndex (instances[instanceIdx + gl_InstanceID].startIndices[2])","#define hasNormalMap (bool(instances[instanceIdx + gl_InstanceID].startIndices[3] == 1))","#define modelTransformation (instances[instanceIdx + gl_InstanceID].modelTransformation)","layout(std140, binding = 0) restrict readonly buffer BindInverse { mat3x4 bindInverseMatrices[]; };","layout(std140, binding = 4) restrict readonly buffer BoneMatrices { mat3x4 boneMatrices[]; };","#else","#ifdef SSBO_SKELETON","uniform ivec2 startIndices;","#define matricesStartIndex startIndices.x","#define boneMatrixStartIndex startIndices.y","layout(std140, binding = 0) restrict readonly buffer BindInverse { mat3x4 bindInverseMatrices[]; };","mat3x4 getBindInverse(in int index) { return bindInverseMatrices[matricesStartIndex + index]; }","layout(std140, binding = 4) restrict readonly buffer BoneMatrices { mat3x4 boneMatrices[]; };","mat3x4 getBoneMatrix(in int idx) { return boneMatrices[boneMatrixStartIndex + idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices[boneMatrixStartIndex + idx - 1]; }","#elif defined(UBO_AVAILABLE)","layout(std140) uniform Skeleton0","{","mat3x4 boneMatrices[MAX_BONES];","};","mat3x4 getBoneMatrix(in int idx) { return boneMatrices[idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices[idx - 1]; }","layout(std140) uniform BindPose","{","mat3x4 bindInverse[MAX_BONES];","};","mat3x4 getBindInverse(in int index) { return bindInverse[index]; }","#elif defined(CPU_SKELETON)","uniform mat3x4 boneMatrices3x4[MAX_BONES];","mat3x4 getBoneMatrix(in int idx) { return boneMatrices3x4[idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices3x4[idx - 1]; }","#else","mat3x4 getBoneMatrix(in int idx) { return mat3x4(0.0); }","mat3x4 calcBoneMatrix(in int idx) { return mat3x4(0.0); }","#endif","#endif","void translate(inout mat4 m, in vec3 v)","{","m[0].xyz += m[0][3] * v;","m[1].xyz += m[1][3] * v;","m[2].xyz += m[2][3] * v;","m[3].xyz += m[3][3] * v;","}","void matrixScale(inout mat4 m, in float s)","{","m[0][0] *= s;","m[0][1] *= s;","m[0][2] *= s;","m[0][3] *= s;","m[1][0] *= s;","m[1][1] *= s;","m[1][2] *= s;","m[1][3] *= s;","m[2][0] *= s;","m[2][1] *= s;","m[2][2] *= s;","m[2][3] *= s;","}","mat3x4 mat34mul(in mat3x4 m1, in mat3x4 m2)","{","mat4 m = mat4(m2[0], m2[1], m2[2], vec4(0.0, 0.0, 0.0, 1.0)) * mat4(m1[0], m1[1], m1[2], vec4(0.0, 0.0, 0.0, 1.0));","return mat3x4(m[0], m[1], m[2]);","}","vec4 quaternionMultiply(in vec4 q1, in vec4 q2)","{","return vec4(cross(q1.xyz, q2.xyz) + q1.w * q2.xyz + q2.w * q1.xyz, q1.w * q2.w - dot(q1.xyz, q2.xyz));","}","mat4 quaternionMatrix4(in vec4 q)","{","float xx = 2.0 * q.x * q.x;","float yy = 2.0 * q.y * q.y;","float zz = 2.0 * q.z * q.z;","float xy = 2.0 * q.x * q.y;","float xz = 2.0 * q.x * q.z;","float yz = 2.0 * q.y * q.z;","float wx = 2.0 * q.w * q.x;","float wy = 2.0 * q.w * q.y;","float wz = 2.0 * q.w * q.z;","return mat4(","1.0 - yy - zz, xy + wz, xz - wy, 0.0,","xy - wz, 1.0 - xx - zz, yz + wx, 0.0,","xz + wy, yz - wx, 1.0 - xx - yy, 0.0,","0.0, 0.0, 0.0, 1.0",");","}","mat3 quaternionMatrix3(in vec4 q)","{","float xx = 2.0 * q.x * q.x;","float yy = 2.0 * q.y * q.y;","float zz = 2.0 * q.z * q.z;","float xy = 2.0 * q.x * q.y;","float xz = 2.0 * q.x * q.z;","float yz = 2.0 * q.y * q.z;","float wx = 2.0 * q.w * q.x;","float wy = 2.0 * q.w * q.y;","float wz = 2.0 * q.w * q.z;","return mat3(","1.0 - yy - zz, xy + wz, xz - wy,","xy - wz, 1.0 - xx - zz, yz + wx,","xz + wy, yz - wx, 1.0 - xx - yy",");","}","vec4 quaternionSlerp(in vec4 qa, in vec4 qb, in float t)","{","float cosHalfTheta = dot(qa, qb);","if (cosHalfTheta >= 0.999999f) return normalize(mix(qa, qb, t));","if (cosHalfTheta <= -0.999999f) return qa;","float halfTheta = acos(cosHalfTheta);","float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);","if (abs(sinHalfTheta) < 0.001) return normalize(mix(qa, qb, t));","float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;","float ratioB = sin(t * halfTheta) / sinHalfTheta;","return qa * ratioA + qb * ratioB;","}","vertAttrib(0, vec3, vertexAttribute0);","vertAttrib(1, vec4, vertexAttribute1);","vertAttrib(2, vec3, vertexAttribute2);","vertAttrib(3, vec3, vertexAttribute3);","vertAttrib(6, vec3, vertexAttribute6);","vertAttrib(7, vec3, vertexAttribute7);","vertAttrib(10, vec2, texCoord);","vertAttrib(11, uvec2, vertexAttribute11);","#define vertex1 vertexAttribute0","#define normal1 vertexAttribute2","#define vertex2 vertexAttribute6","#define normal2 vertexAttribute7","#define staticVertex vertexAttribute0","#define staticNormal (vertexAttribute1.xyz)","#define skeletalVertex vertexAttribute0","#define skeletalNormal (vertexAttribute1.xyz)","#ifdef WEIGHT_NORMAL_PACKED","#define boneWeight0 (vertexAttribute1.w)","#else","#define boneWeight0 (vertexAttribute2.x)","#endif","#define boneIndices vertexAttribute11","#ifndef BATCHED","uniform vec4 v4params[7];","uniform float attachmentBoneIndex;","uniform bool hasNormalMap;","#endif","uniform mat4 viewProjection;","uniform int geometryType;","uniform vec3 cameraPosition;","#ifdef FOG_OF_WAR","uniform vec4 fowMapScalePosition;","#endif","#define GEOM_MORPH 0","#define GEOM_STATIC 2","#define GEOM_SKELETAL 3","#ifndef DEFERRED","uniform mat4 sunMatrix;","#endif","uniform float interpolationParameter;","smooth out vec3 fragNormal;","smooth out vec4 fragTexCoordWorldVertexPositionXy;","smooth out vec3 fragInterpolatedVertex;","#ifndef DEFERRED","smooth out vec3 sunVertexPosition;","#endif","#define fragTexCoord (fragTexCoordWorldVertexPositionXy.xy)","#define worldVertexPositionXy (fragTexCoordWorldVertexPositionXy.zw)","void interpolateMorph(out vec3 vertex, out vec3 normal)","{","vertex = mix(vertex1, vertex2, interpolationParameter);","#ifdef NORMALIZE_INT10_MANUALLY","normal = mix(normal1 / 512.0, normal2 / 512.0, interpolationParameter);","#else","normal = mix(normal1, normal2, interpolationParameter);","#endif","}","void interpolateSkeletal(out vec3 vertex, out vec3 normal)","{","#if defined(BATCHED)","int invIdx = instances[instanceIdx + gl_InstanceID].startIndices[0];","int matIdx = instances[instanceIdx + gl_InstanceID].startIndices[1];","mat3x4 m1 = mat34mul(boneMatrices[matIdx + int(boneIndices.x)], bindInverseMatrices[invIdx + int(boneIndices.x)]);","mat3x4 m2 = mat34mul(boneMatrices[matIdx + int(boneIndices.y)], bindInverseMatrices[invIdx + int(boneIndices.y)]);","#elif defined(SSBO_SKELETON) || defined(UBO_AVAILABLE)","mat3x4 m1 = mat34mul(getBoneMatrix(int(boneIndices.x)), getBindInverse(int(boneIndices.x)));","mat3x4 m2 = mat34mul(getBoneMatrix(int(boneIndices.y)), getBindInverse(int(boneIndices.y)));","#else","mat3x4 m1 = getBoneMatrix(int(boneIndices.x));","mat3x4 m2 = getBoneMatrix(int(boneIndices.y));","#endif","vec3 v1 = (vec4(skeletalVertex, 1.0) * m1).xyz;","vec3 v2 = (vec4(skeletalVertex, 1.0) * m2).xyz;","vec3 n1 = skeletalNormal * mat3(m1);","vec3 n2 = skeletalNormal * mat3(m2);","float boneWeight1 = 1.0 - boneWeight0;","vertex = v1 * boneWeight0 + v2 * boneWeight1;","normal = n1 * boneWeight0 + n2 * boneWeight1;","}","uniform vec4 attachmentDisplacementScale;","#ifdef SSBO_SKELETON","mat3x4 getAttachmentBoneMatrix(in int index)","{","if (index == 0u) return mat3x4(1.0);","mat3x4 m = boneMatrices[index];","m[0].xyz *= attachmentDisplacementScale.w;","m[1].xyz *= attachmentDisplacementScale.w;","m[2].xyz *= attachmentDisplacementScale.w;","m[0][3] += attachmentDisplacementScale.x;","m[1][3] += attachmentDisplacementScale.y;","m[2][3] += attachmentDisplacementScale.z;","return m;","}","#elif defined(UBO_AVAILABLE)","layout(std140) uniform Skeleton5","{","mat3x4 attachmentMatrices[MAX_BONES];","};","mat3x4 getAttachmentBoneMatrix(in int index)","{","if (index == 0) return mat3x4(1.0);","mat3x4 m = attachmentMatrices[index];","m[0].xyz *= attachmentDisplacementScale.w;","m[1].xyz *= attachmentDisplacementScale.w;","m[2].xyz *= attachmentDisplacementScale.w;","m[0][3] += attachmentDisplacementScale.x;","m[1][3] += attachmentDisplacementScale.y;","m[2][3] += attachmentDisplacementScale.z;","return m;","}","#elif defined(CPU_SKELETON)","uniform mat3x4 attachmentMatrix;","mat3x4 getAttachmentBoneMatrix(in int index) { return attachmentMatrix; }","#else","mat3x4 getAttachmentBoneMatrix(in int index) { return mat3x4(1.0); }","#endif","void main()","{","#ifdef BATCHED","instanceId = gl_InstanceID;","instancingVaryingData.y = int(hasNormalMap);","#endif","vec3 interpolatedVertex;","vec3 interpolatedNormal;","switch (geometryType) {","case GEOM_MORPH:","interpolateMorph(interpolatedVertex, interpolatedNormal);","break;","case GEOM_STATIC:","interpolatedVertex = staticVertex;","interpolatedNormal = staticNormal;","break;","case GEOM_SKELETAL:","interpolateSkeletal(interpolatedVertex, interpolatedNormal);","break;","default:","interpolatedVertex = vec3(0.0, 0.0, 0.0);","interpolatedNormal = vec3(0.0, 0.0, 0.0);","}","#ifndef BATCHED","mat4 modelTransformation = mat4(v4params[3], v4params[4], v4params[5], v4params[6]);","#endif","fragTexCoord = texCoord;","mat3x4 attachmentBoneMatrix = getAttachmentBoneMatrix(int(attachmentBoneIndex));","vec4 position = modelTransformation * vec4(vec4(interpolatedVertex, 1.0) * attachmentBoneMatrix, 1.0);","fragInterpolatedVertex = position.xyz;","gl_Position = viewProjection * position;","fragNormal = normalize(mat3(modelTransformation) * (interpolatedNormal * mat3(attachmentBoneMatrix)));","#ifndef DEFERRED","sunVertexPosition = (sunMatrix * position).xyz;","#endif","#ifdef FOG_OF_WAR","worldVertexPositionXy = position.xy * fowMapScalePosition.xy + fowMapScalePosition.zw;","#else","worldVertexPositionXy = vec2(0.0);","#endif","}"]}}
