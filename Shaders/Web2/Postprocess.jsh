{"meta":{"feedback_varyings":null,"interface_block_bindings":null,"sampler_default_values":[["bloomTex",1],["colorGradingLutCube",7],["colorGradingLutSeparable",7],["colorTex",0],["displacementTex",8],["foggedTexture",4],["fow",5],["overlay",6]],"shader_parameters":[["fragment","vec3","bloomColor",1],["fragment","vec2","bloomTexelSize",1],["fragment","sampler2D","bloomTex",1],["fragment","vec2","bloomVars",1],["fragment","sampler3D","colorGradingLutCube",1],["fragment","sampler2D","colorGradingLutSeparable",1],["fragment","sampler2D","colorTex",1],["fragment","sampler2D","displacementTex",1],["fragment","float","exposure",1],["fragment","sampler2D","foggedTexture",1],["fragment","float","fow0Strength",1],["fragment","vec3","fowColorFactors",2],["fragment","vec4","fowPositionScale",2],["fragment","sampler2D","fow",1],["fragment","vec2","inverseScreenSize",1],["fragment","vec2","lutSizeFactorHalftexel",1],["fragment","sampler2D","overlay",1],["fragment","float","whiteLuminance",1]],"vertex_attributes":null},"stages":{"fragment":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#ifdef FOG_OF_WAR_POSTPROCESS","#define DECLARE_FRAGCOLOR layout(location = 0) out vec4 outFragColor; layout(location = 2) out vec4 outFowBuffer;","#else","#define DECLARE_FRAGCOLOR layout(location = 0) out vec4 outFragColor;","#endif","#define outFragDepth gl_FragDepth","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","vec3 unpackRgNormal(in vec2 xy)","{","xy = xy * 2.0 - 1.0;","return vec3(xy, sqrt(max(0.0, 1.0 - dot(xy, xy))));","}","vec3 sampleNormalmap(in sampler2D tex, in vec2 tc)","{","return unpackRgNormal(SAMPLE_2D(tex, tc).NM_XY);","}","vec3 downsample13(in sampler2D tex, in vec2 tc, in vec2 texelSize)","{","vec3 s1  = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0, -1.0)).rgb;","vec3 s2  = SAMPLE_2D(tex, tc + texelSize * vec2( 0.0, -1.0)).rgb;","vec3 s3  = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0, -1.0)).rgb;","vec3 s4  = SAMPLE_2D(tex, tc + texelSize * vec2(-0.5, -0.5)).rgb;","vec3 s5  = SAMPLE_2D(tex, tc + texelSize * vec2( 0.5, -0.5)).rgb;","vec3 s6  = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0,  0.0)).rgb;","vec3 s7  = SAMPLE_2D(tex, tc).rgb;","vec3 s8  = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0,  0.0)).rgb;","vec3 s9  = SAMPLE_2D(tex, tc + texelSize * vec2(-0.5,  0.5)).rgb;","vec3 s10 = SAMPLE_2D(tex, tc + texelSize * vec2( 0.5,  0.5)).rgb;","vec3 s11 = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0,  1.0)).rgb;","vec3 s12 = SAMPLE_2D(tex, tc + texelSize * vec2( 0.0,  1.0)).rgb;","vec3 s13 = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0,  1.0)).rgb;","return","(s4 + s5 + s9 + s10) * 0.125 +","(s1 + s2 + s7 + s6) * 0.03125 +","(s2 + s3 + s8 + s7) * 0.03125 +","(s6 + s7 + s12 + s11) * 0.03125 +","(s7 + s8 + s13 + s12) * 0.03125;","}","vec3 downsample4(in sampler2D tex, in vec2 tc, in vec2 texelSize)","{","vec4 displacement = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);","vec3 s =","SAMPLE_2D(tex, tc + displacement.xy).rgb +","SAMPLE_2D(tex, tc + displacement.zy).rgb +","SAMPLE_2D(tex, tc + displacement.xw).rgb +","SAMPLE_2D(tex, tc + displacement.zw).rgb;","return s * 0.25;","}","vec3 magTent(in sampler2D tex, in vec2 uv, in vec2 texelSize, in float sampleScale)","{","vec4 displacement = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;","vec3 result =","SAMPLE_2D(tex, uv - displacement.xy).rgb +","SAMPLE_2D(tex, uv - displacement.wy).rgb * 2.0 +","SAMPLE_2D(tex, uv - displacement.zy).rgb +","SAMPLE_2D(tex, uv + displacement.zw).rgb * 2.0 +","SAMPLE_2D(tex, uv).rgb * 4.0 +","SAMPLE_2D(tex, uv + displacement.xw).rgb * 2.0 +","SAMPLE_2D(tex, uv + displacement.zy).rgb +","SAMPLE_2D(tex, uv + displacement.wy).rgb * 2.0 +","SAMPLE_2D(tex, uv + displacement.xy).rgb;","return result * 0.0625;","}","vec3 magBox(in sampler2D tex, in vec2 tc, in vec2 texelSize, in float sampleScale)","{","vec4 displacement = texelSize.xyxy * vec4(-0.5, -0.5, 0.5, 0.5) * sampleScale;","vec3 s =","SAMPLE_2D(tex, (tc + displacement.xy)).rgb +","SAMPLE_2D(tex, (tc + displacement.zy)).rgb +","SAMPLE_2D(tex, (tc + displacement.xw)).rgb +","SAMPLE_2D(tex, (tc + displacement.zw)).rgb;","return s * 0.25;","}","uniform sampler2D colorTex ;","DECLARE_FRAGCOLOR","smooth in vec2 texCoord;","uniform vec2 inverseScreenSize;","uniform float exposure;","uniform float whiteLuminance;","#if defined(BLOOM_BAD) || defined(BLOOM_GOOD)","uniform vec2 bloomTexelSize;","uniform vec2 bloomVars;","uniform vec3 bloomColor;","uniform sampler2D bloomTex ;","vec3 addBloom(in vec3 color, in vec2 displacement)","{","vec3 bloom;","#ifdef BLOOM_GOOD","bloom = magTent(bloomTex, texCoord + displacement, bloomTexelSize, bloomVars.x);","#else","bloom = magBox(bloomTex, texCoord + displacement, bloomTexelSize, bloomVars.x);","#endif","return color + bloom * bloomColor * bloomVars.y;","}","#else","vec3 addBloom(in vec3 color, in vec2 displacement) { return color; }","#endif","#ifdef FOG_OF_WAR","uniform sampler2D foggedTexture ;","uniform sampler2D fow ;","uniform vec4 fowPositionScale[2];","uniform vec3 fowColorFactors[2];","uniform float fow0Strength;","#endif","uniform sampler2D overlay ;","#ifdef COLOR_GRADING_CUBE","uniform sampler3D colorGradingLutCube ;","#elif defined(COLOR_GRADING_SEPARABLE)","uniform sampler2D colorGradingLutSeparable ;","#endif","#if defined(COLOR_GRADING_CUBE) || defined(COLOR_GRADING_SEPARABLE)","uniform vec2 lutSizeFactorHalftexel;","#define lutSizeFactor lutSizeFactorHalftexel.x","#define lutHalfTexel lutSizeFactorHalftexel.y","#endif","#ifdef DISPLACEMENT_ENABLED","uniform sampler2D displacementTex ;","#endif","float rgb2luma(in vec3 rgb) {","return sqrt(dot(rgb, vec3(0.299, 0.587, 0.114)));","}","const float EDGE_THRESHOLD_MIN = 1.0 / 128.0;","const float EDGE_THRESHOLD_MAX = 0.125;","const int FXAA_ITERATIONS = 12;","const float SUBPIXEL_QUALITY = 0.75;","const float fxaaQuality[] = float[](1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 4.0, 8.0);","vec3 getFxaaMainColor()","{","vec3 colorCenter = texture(colorTex, texCoord).rgb;","float lumaCenter = rgb2luma(colorCenter);","float lumaDown = rgb2luma(textureOffset(colorTex, texCoord, ivec2(0, -1)).rgb);","float lumaUp = rgb2luma(textureOffset(colorTex, texCoord, ivec2(0, 1)).rgb);","float lumaLeft = rgb2luma(textureOffset(colorTex, texCoord, ivec2(-1, 0)).rgb);","float lumaRight = rgb2luma(textureOffset(colorTex, texCoord, ivec2(1, 0)).rgb);","float lumaMin = min(lumaCenter, min(min(lumaDown, lumaUp), min(lumaLeft, lumaRight)));","float lumaMax = max(lumaCenter, max(max(lumaDown, lumaUp), max(lumaLeft, lumaRight)));","float lumaRange = lumaMax - lumaMin;","if(lumaRange < max(EDGE_THRESHOLD_MIN, lumaMax * EDGE_THRESHOLD_MAX)) return colorCenter;","float lumaDownLeft = rgb2luma(textureOffset(colorTex, texCoord, ivec2(-1, -1)).rgb);","float lumaUpRight = rgb2luma(textureOffset(colorTex, texCoord, ivec2(1, 1)).rgb);","float lumaUpLeft = rgb2luma(textureOffset(colorTex, texCoord, ivec2(-1, 1)).rgb);","float lumaDownRight = rgb2luma(textureOffset(colorTex, texCoord, ivec2(1, -1)).rgb);","float lumaDownUp = lumaDown + lumaUp;","float lumaLeftRight = lumaLeft + lumaRight;","float lumaLeftCorners = lumaDownLeft + lumaUpLeft;","float lumaDownCorners = lumaDownLeft + lumaDownRight;","float lumaRightCorners = lumaDownRight + lumaUpRight;","float lumaUpCorners = lumaUpRight + lumaUpLeft;","float edgeHorizontal =  abs(-2.0 * lumaLeft + lumaLeftCorners)  + abs(-2.0 * lumaCenter + lumaDownUp ) * 2.0    + abs(-2.0 * lumaRight + lumaRightCorners);","float edgeVertical =    abs(-2.0 * lumaUp + lumaUpCorners)      + abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0  + abs(-2.0 * lumaDown + lumaDownCorners);","bool isHorizontal = (edgeHorizontal >= edgeVertical);","float luma1 = isHorizontal ? lumaDown : lumaLeft;","float luma2 = isHorizontal ? lumaUp : lumaRight;","float gradient1 = luma1 - lumaCenter;","float gradient2 = luma2 - lumaCenter;","bool is1Steepest = abs(gradient1) >= abs(gradient2);","float gradientScaled = 0.25 * max(abs(gradient1), abs(gradient2));","float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;","float lumaLocalAverage = 0.0;","if(is1Steepest) {","stepLength = - stepLength;","lumaLocalAverage = 0.5 * (luma1 + lumaCenter);","}","else lumaLocalAverage = 0.5 * (luma2 + lumaCenter);","vec2 currentUv = texCoord;","if (isHorizontal) currentUv.y += stepLength * 0.5;","else currentUv.x += stepLength * 0.5;","vec2 offset = isHorizontal ? vec2(inverseScreenSize.x, 0.0) : vec2(0.0, inverseScreenSize.y);","vec2 uv1 = currentUv - offset;","vec2 uv2 = currentUv + offset;","float lumaEnd1 = rgb2luma(texture(colorTex, uv1).rgb);","float lumaEnd2 = rgb2luma(texture(colorTex, uv2).rgb);","lumaEnd1 -= lumaLocalAverage;","lumaEnd2 -= lumaLocalAverage;","bool reached1 = abs(lumaEnd1) >= gradientScaled;","bool reached2 = abs(lumaEnd2) >= gradientScaled;","bool reachedBoth = reached1 && reached2;","if (!reached1) uv1 -= offset;","if (!reached2) uv2 += offset;","if (!reachedBoth) {","for (int i = 2; i < FXAA_ITERATIONS; i++) {","if (!reached1) {","lumaEnd1 = rgb2luma(texture(colorTex, uv1).rgb);","lumaEnd1 = lumaEnd1 - lumaLocalAverage;","}","if (!reached2) {","lumaEnd2 = rgb2luma(texture(colorTex, uv2).rgb);","lumaEnd2 = lumaEnd2 - lumaLocalAverage;","}","reached1 = abs(lumaEnd1) >= gradientScaled;","reached2 = abs(lumaEnd2) >= gradientScaled;","reachedBoth = reached1 && reached2;","if (!reached1) uv1 -= offset * fxaaQuality[i];","if (!reached2) uv2 += offset * fxaaQuality[i];","if (reachedBoth) break;","}","}","float distance1 = isHorizontal ? (texCoord.x - uv1.x) : (texCoord.y - uv1.y);","float distance2 = isHorizontal ? (uv2.x - texCoord.x) : (uv2.y - texCoord.y);","bool isDirection1 = distance1 < distance2;","float distanceFinal = min(distance1, distance2);","float edgeThickness = (distance1 + distance2);","float pixelOffset = - distanceFinal / edgeThickness + 0.5;","bool isLumaCenterSmaller = lumaCenter < lumaLocalAverage;","bool correctVariation = ((isDirection1 ? lumaEnd1 : lumaEnd2) < 0.0) != isLumaCenterSmaller;","float finalOffset = correctVariation ? pixelOffset : 0.0;","float lumaAverage = (1.0/12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);","float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter)/lumaRange,0.0,1.0);","float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;","float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;","finalOffset = max(finalOffset,subPixelOffsetFinal);","vec2 finalUv = texCoord;","if (isHorizontal) finalUv.y += finalOffset * stepLength;","else finalUv.x += finalOffset * stepLength;","return texture(colorTex, finalUv).rgb;","}","vec3 rgb2yxy(in vec3 rgb)","{","const mat3 rgb2xyz = mat3(","0.4124564, 0.2126729, 0.0193339,","0.3575761, 0.7151522, 0.1191920,","0.1804375, 0.0721750, 0.9503041",");","vec3 xyz = rgb2xyz * rgb;","float sum = xyz.r + xyz.g + xyz.b;","return vec3(xyz.g, xyz.r / sum, xyz.g / sum);","}","vec3 yxy2rgb(in vec3 yxy)","{","vec3 xyz = vec3(yxy.r * yxy.g / yxy.b, yxy.r, (1.0 - yxy.g - yxy.b) * (yxy.r / yxy.b));","const mat3 xyz2rgb = mat3(","3.2404542, -0.9692660, 0.0556434,","-1.5371385, 1.8760108, -0.2040259,","-0.4985314, 0.0415560, 1.0572252",");","return clamp(xyz2rgb * xyz, 0.0, 1.0);","}","float acesApprox(in float v)","{","v *= 0.6;","float a = 2.51;","float b = 0.03;","float c = 2.43;","float d = 0.59;","float e = 0.14;","return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);","}","void main()","{","#ifdef DISPLACEMENT_ENABLED","#ifdef TARGET_IS_INT8SNORM","vec2 pixelDisp = texture(displacementTex, texCoord).rg * 0.1;","#else","vec2 pixelDisp = texture(displacementTex, texCoord).rg;","#endif","#else","vec2 pixelDisp = vec2(0.0);","#endif","#ifdef FXAA_ENABLED","#ifdef DISPLACEMENT_ENABLED","outFragColor.rgb = any(bvec2(pixelDisp.x != 0.0, pixelDisp.y != 0.0)) ? texture(colorTex, texCoord + pixelDisp).rgb : getFxaaMainColor();","#else","outFragColor.rgb = getFxaaMainColor();","#endif","#else","outFragColor.rgb = texture(colorTex, texCoord + pixelDisp).rgb;","#endif","outFragColor.rgb = addBloom(outFragColor.rgb, pixelDisp);","#ifdef TM_MODREINHARD","vec3 yxy = rgb2yxy(outFragColor.rgb);","float lAdj = yxy.r * exposure;","yxy.r = (lAdj * (1.0 + lAdj/(whiteLuminance * whiteLuminance)))/(1.0 + lAdj);","outFragColor.rgb = yxy2rgb(yxy);","#endif","#ifdef COLOR_GRADING_CUBE","outFragColor.rgb = texture(colorGradingLutCube, outFragColor.rgb * lutSizeFactor + vec3(lutHalfTexel)).rgb;","#elif defined(COLOR_GRADING_SEPARABLE)","outFragColor.r = texture(colorGradingLutSeparable, vec2(outFragColor.r * lutSizeFactor + lutHalfTexel, 0.5)).r;","outFragColor.g = texture(colorGradingLutSeparable, vec2(outFragColor.g * lutSizeFactor + lutHalfTexel, 0.5)).g;","outFragColor.b = texture(colorGradingLutSeparable, vec2(outFragColor.b * lutSizeFactor + lutHalfTexel, 0.5)).b;","#endif","#ifdef FOG_OF_WAR","float fowFactor = texture(fow, texCoord + pixelDisp).r;","vec2 fow0TexCoord = texCoord * fowPositionScale[0].zw - fowPositionScale[0].xy;","vec2 fow1TexCoord = texCoord * fowPositionScale[1].zw - fowPositionScale[1].xy;","vec3 fow0Color = texture(foggedTexture, fow0TexCoord + pixelDisp).rgb * fowColorFactors[0];","vec3 fow1Color = texture(foggedTexture, fow1TexCoord + pixelDisp).rgb * fowColorFactors[1];","vec3 fowColor = mix(fow0Color, fow1Color, fow0Strength);","outFragColor.rgb = mix(fowColor, outFragColor.rgb, fowFactor);","#endif","vec4 overlayColor = texture(overlay, texCoord + pixelDisp);","outFragColor.rgb = mix(outFragColor.rgb, overlayColor.rgb, overlayColor.a);","outFragColor.a = 1.0;","}"],"vertex":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","const vec2 quad01[] = vec2[](","vec2(0.0, 1.0),","vec2(0.0, 0.0),","vec2(1.0, 1.0),","vec2(1.0, 0.0)",");","const vec3 fullscreenQuad[] = vec3[](","vec3(-1.0, 1.0, -1.0),","vec3(-1.0, -1.0, -1.0),","vec3(1.0, 1.0, -1.0),","vec3(1.0, -1.0, -1.0)",");","smooth out vec2 texCoord;","void main()","{","texCoord = quad01[gl_VertexID];","gl_Position = vec4(fullscreenQuad[gl_VertexID].xy, 0.0, 1.0);","}"]}}
