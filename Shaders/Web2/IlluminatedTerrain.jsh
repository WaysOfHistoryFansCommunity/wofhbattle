{"meta":{"feedback_varyings":null,"interface_block_bindings":null,"sampler_default_values":[["color2Tex",5],["colorClimateTex",3],["colorTex",0],["combineTex",9],["fogOfWar",6],["heightTex",2],["normalMap",4],["normalTex",1],["shadowTex",7],["specularRoughnessTex",8]],"shader_parameters":[["vertex","sampler2D","color2Tex",1],["vertex","sampler2D","colorClimateTex",1],["fragment","sampler2D","colorTex",1],["fragment","sampler2D","combineTex",1],["fragment","vec3","darkColor",1],["fragment","vec4","fogColor",1],["fragment","vec2","fogNearFar",1],["fragment","sampler2D","fogOfWar",1],["fragment","float","fowInterpolationParameter",1],["vertex","vec4","fowMapScalePosition",1],["vertex","vec2","heightTerrainScale",1],["vertex","sampler2D","heightTex",1],["fragment","vec3","lightColor",1],["fragment","vec3","lightDirection",1],["fragment","float","metalness",1],["vertex","sampler2D","normalMap",1],["fragment","sampler2D","normalTex",1],["fragment","float","normalZScale",1],["vertex","vec2","patchOrigin",1],["fragment","vec2","shadowBiasScaleMax",1],["fragment","vec4","shadowMapSize",1],["fragment","sampler2D","shadowTex",1],["fragment","float","specularFactor",1],["fragment","float","specularPower",1],["fragment","sampler2D","specularRoughnessTex",1],["fragment","vec3","submarineBottomDiffWl",1],["fragment","vec3","submarineColorMultiplier",1],["fragment","float","sunFarFadeFactor",1],["vertex","mat4","sunMatrix",1],["vertex","vec2","terrainSize",1],["fragment","float","textureScale",1],["vertex","float","textureScale",1],["fragment","vec2","tileCoordMul",1],["fragment","vec4","tileSizes",1],["vertex","vec4","tileSizes",1],["vertex","vec4","tilesCount",1],["vertex","float","triplanarTransitionSharpnessMap",64],["vertex","vec3","viewCameraPosition",1],["vertex","mat4","viewProjectionMatrix",1],["fragment","float","zGridScale",1]],"vertex_attributes":[[0,"vec2","vertexData"],[1,"vec2","patchOrigin"]]},"stages":{"fragment":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#ifdef FOG_OF_WAR_POSTPROCESS","#define DECLARE_FRAGCOLOR layout(location = 0) out vec4 outFragColor; layout(location = 2) out vec4 outFowBuffer;","#else","#define DECLARE_FRAGCOLOR layout(location = 0) out vec4 outFragColor;","#endif","#define outFragDepth gl_FragDepth","#ifdef FOG","uniform vec2 fogNearFar;","uniform vec4 fogColor;","float getFogFactor(in float zEye)","{","float fogNear = fogNearFar[0];","float fogFar = fogNearFar[1];","return clamp((zEye - fogNear) / (fogFar - fogNear), 0.0, 1.0) * fogColor.a;","}","vec3 addFogFactor(in vec3 color, in float fogFactor)","{","return mix(color, fogColor.rgb, fogFactor);","}","vec3 addFog(in vec3 color, in float zEye)","{","float fogFactor = getFogFactor(zEye);","return addFogFactor(color, fogFactor);","}","#else","float getFogFactor(in float zEye)","{","return 0.0;","}","vec3 addFogFactor(in vec3 color, in float fogFactor)","{","return color;","}","vec3 addFog(in vec3 color, in float zEye)","{","return color;","}","#endif","#ifdef FOG_OF_WAR","uniform sampler2D fogOfWar ;","uniform float fowInterpolationParameter;","float getFogOfWarFactor(in vec2 tc)","{","const float border0 = -0.001;","const float border1 = 1.001;","float clampTo0 = step(border0, tc.x) * (1.0 - step(border1, tc.x)) * step(border0, tc.y) * (1.0 - step(border1, tc.y));","vec2 rg = texture(fogOfWar, tc).rg * clampTo0;","return mix(rg.r, rg.g, fowInterpolationParameter);","}","#else","float getFogOfWarFactor(in vec2 tc) { return 1.0; }","#endif","float mapTo01(in float value, in float min1, in float max1) {","return clamp((value - min1) / (max1 - min1), 0.0, 1.0);","}","float linearizeDepth(in float d, in float zNear, in float zFar)","{","float z_n = 2.0 * d - 1.0;","return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));","}","float istep(float edge, float x)","{","return step(x, edge);","}","float plate(float edge1, float edge2, float x)","{","return step(edge1, x) * step(x, edge2);","}","float textureBorder1(sampler2D s, vec2 uv)","{","float inTexture = plate(0.0, 1.0, uv.x) * plate(0.0, 1.0, uv.y);","return inTexture * texture(s, uv).r + (1.0 - inTexture);","}","float textureCompare(sampler2D depth, vec2 uv, float zReceiver, float bias)","{","float shadowDepth = textureBorder1(depth, uv);","if (((shadowDepth + bias) < zReceiver) && (zReceiver <= 1.0)) return 1.0;","return 0.0;","}","uniform float sunFarFadeFactor;","float farShadowFade(in float uvy)","{","return (1.0 - smoothstep(sunFarFadeFactor, 1.0, uvy));","}","uniform vec2 shadowBiasScaleMax;","float shadowBias(vec3 normal, vec3 toSun)","{","return max(shadowBiasScaleMax.x * (1.0 - dot(normal, toSun)), shadowBiasScaleMax.y);","}","#if defined(SHADOWED_PCSS)","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#define BLOCKER_SEARCH_NUM_SAMPLES 16","#define PCF_NUM_SAMPLES 64","#define LIGHT_SIZE_UV 0.01","#define NEAR_PLANE 1.0","float PenumbraSize(float zReceiver, float zBlocker)","{","return (zReceiver - zBlocker) / zBlocker;","}","float PCF_Filter(sampler2D depth, vec2 uv, float zReceiver, float filterRadiusUV, float bias)","{","vec2 poissonDisk[64];","poissonDisk[0] = vec2(-0.613392, 0.617481);","poissonDisk[1] = vec2(0.170019, -0.040254);","poissonDisk[2] = vec2(-0.299417, 0.791925);","poissonDisk[3] = vec2(0.645680, 0.493210);","poissonDisk[4] = vec2(-0.651784, 0.717887);","poissonDisk[5] = vec2(0.421003, 0.027070);","poissonDisk[6] = vec2(-0.817194, -0.271096);","poissonDisk[7] = vec2(-0.705374, -0.668203);","poissonDisk[8] = vec2(0.977050, -0.108615);","poissonDisk[9] = vec2(0.063326, 0.142369);","poissonDisk[10] = vec2(0.203528, 0.214331);","poissonDisk[11] = vec2(-0.667531, 0.326090);","poissonDisk[12] = vec2(-0.098422, -0.295755);","poissonDisk[13] = vec2(-0.885922, 0.215369);","poissonDisk[14] = vec2(0.566637, 0.605213);","poissonDisk[15] = vec2(0.039766, -0.396100);","poissonDisk[16] = vec2(0.751946, 0.453352);","poissonDisk[17] = vec2(0.078707, -0.715323);","poissonDisk[18] = vec2(-0.075838, -0.529344);","poissonDisk[19] = vec2(0.724479, -0.580798);","poissonDisk[20] = vec2(0.222999, -0.215125);","poissonDisk[21] = vec2(-0.467574, -0.405438);","poissonDisk[22] = vec2(-0.248268, -0.814753);","poissonDisk[23] = vec2(0.354411, -0.887570);","poissonDisk[24] = vec2(0.175817, 0.382366);","poissonDisk[25] = vec2(0.487472, -0.063082);","poissonDisk[26] = vec2(-0.084078, 0.898312);","poissonDisk[27] = vec2(0.488876, -0.783441);","poissonDisk[28] = vec2(0.470016, 0.217933);","poissonDisk[29] = vec2(-0.696890, -0.549791);","poissonDisk[30] = vec2(-0.149693, 0.605762);","poissonDisk[31] = vec2(0.034211, 0.979980);","poissonDisk[32] = vec2(0.503098, -0.308878);","poissonDisk[33] = vec2(-0.016205, -0.872921);","poissonDisk[34] = vec2(0.385784, -0.393902);","poissonDisk[35] = vec2(-0.146886, -0.859249);","poissonDisk[36] = vec2(0.643361, 0.164098);","poissonDisk[37] = vec2(0.634388, -0.049471);","poissonDisk[38] = vec2(-0.688894, 0.007843);","poissonDisk[39] = vec2(0.464034, -0.188818);","poissonDisk[40] = vec2(-0.440840, 0.137486);","poissonDisk[41] = vec2(0.364483, 0.511704);","poissonDisk[42] = vec2(0.034028, 0.325968);","poissonDisk[43] = vec2(0.099094, -0.308023);","poissonDisk[44] = vec2(0.693960, -0.366253);","poissonDisk[45] = vec2(0.678884, -0.204688);","poissonDisk[46] = vec2(0.001801, 0.780328);","poissonDisk[47] = vec2(0.145177, -0.898984);","poissonDisk[48] = vec2(0.062655, -0.611866);","poissonDisk[49] = vec2(0.315226, -0.604297);","poissonDisk[50] = vec2(-0.780145, 0.486251);","poissonDisk[51] = vec2(-0.371868, 0.882138);","poissonDisk[52] = vec2(0.200476, 0.494430);","poissonDisk[53] = vec2(-0.494552, -0.711051);","poissonDisk[54] = vec2(0.612476, 0.705252);","poissonDisk[55] = vec2(-0.578845, -0.768792);","poissonDisk[56] = vec2(-0.772454, -0.090976);","poissonDisk[57] = vec2(0.504440, 0.372295);","poissonDisk[58] = vec2(0.155736, 0.065157);","poissonDisk[59] = vec2(0.391522, 0.849605);","poissonDisk[60] = vec2(-0.620106, -0.328104);","poissonDisk[61] = vec2(0.789239, -0.419965);","poissonDisk[62] = vec2(-0.545396, 0.538133);","poissonDisk[63] = vec2(-0.178564, -0.596057);","float sum = 0.0;","for ( int i = 0; i < PCF_NUM_SAMPLES; ++i )","{","vec2 offset = poissonDisk[i] * filterRadiusUV;","sum += textureCompare(depth, uv + offset, zReceiver, bias);","}","return sum / float(PCF_NUM_SAMPLES);","}","vec2 FindBlocker(sampler2D depth, vec2 uv, float zReceiver, float bias)","{","vec2 poissonDisk[16];","poissonDisk[0] = vec2 ( -0.94201624, -0.39906216 );","poissonDisk[1] = vec2 ( 0.94558609, -0.76890725 );","poissonDisk[2] = vec2 ( -0.094184101, -0.92938870 );","poissonDisk[3] = vec2 ( 0.34495938, 0.29387760 );","poissonDisk[4] = vec2 ( -0.91588581, 0.45771432 );","poissonDisk[5] = vec2 ( -0.81544232, -0.87912464 );","poissonDisk[6] = vec2 ( -0.38277543, 0.27676845 );","poissonDisk[7] = vec2 ( 0.97484398, 0.75648379 );","poissonDisk[8] = vec2 ( 0.44323325, -0.97511554 );","poissonDisk[9] = vec2 ( 0.53742981, -0.47373420 );","poissonDisk[10] = vec2 ( -0.26496911, -0.41893023 );","poissonDisk[11] = vec2 ( 0.79197514, 0.19090188 );","poissonDisk[12] = vec2 ( -0.24188840, 0.99706507 );","poissonDisk[13] = vec2 ( -0.81409955, 0.91437590 );","poissonDisk[14] = vec2 ( 0.19984126, 0.78641367 );","poissonDisk[15] = vec2 ( 0.14383161, -0.14100790 );","float avgBlockerDepth = 0.0;","float numBlockers = 0.0;","float searchWidth = LIGHT_SIZE_UV * (zReceiver - float(NEAR_PLANE)) / zReceiver;","float blockerSum = 0.0;","for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; ++i) {","vec2 uvDisplaced = uv + poissonDisk[i] * searchWidth;","float shadowMapDepth = textureBorder1(depth, uvDisplaced);","if (((shadowMapDepth + bias) < zReceiver) && !(zReceiver > 1.0)) {","blockerSum += shadowMapDepth;","numBlockers++;","}","}","avgBlockerDepth = blockerSum / numBlockers;","return vec2(avgBlockerDepth, numBlockers);","}","float getShadow(in sampler2D depth, in vec2 uv, in float zReceiver, in float bias, in int cascadeId)","{","vec2 fb = FindBlocker(depth, uv, zReceiver, bias);","float avgBlockerDepth = fb.x;","float numBlockers = fb.y;","if( numBlockers < 1.0 ) return 0.0;","float penumbraRatio = PenumbraSize(zReceiver, avgBlockerDepth);","float filterRadiusUV = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;","float shadowValue = (PCF_Filter(depth, uv, zReceiver, filterRadiusUV, bias));","return shadowValue * farShadowFade(uv.y);","}","#elif defined(SHADOWED_PCF)","uniform vec4 shadowMapSize;","float textureShadowLerp(in sampler2D depths, in vec2 uv, in float zReceiver, in float bias)","{","vec2 texelSize = shadowMapSize.zw;","vec2 centroidUV;","vec2 f = modf(uv * shadowMapSize.xy, centroidUV);","centroidUV *= texelSize;","float lb = textureCompare(depths, centroidUV + texelSize * vec2(0.0, 0.0), zReceiver, bias);","float lt = textureCompare(depths, centroidUV + texelSize * vec2(0.0, 1.0), zReceiver, bias);","float rb = textureCompare(depths, centroidUV + texelSize * vec2(1.0, 0.0), zReceiver, bias);","float rt = textureCompare(depths, centroidUV + texelSize * vec2(1.0, 1.0), zReceiver, bias);","float a = mix(lb, lt, f.y);","float b = mix(rb, rt, f.y);","float c = mix(a, b, f.x);","return c;","}","#ifndef CSM_COUNT","#define CSM_COUNT 1","#endif","float getShadow(in sampler2D depth, in vec2 uv, in float zReceiver, in float bias, in int cascadeId)","{","#if CSM_COUNT > 1","uv.x *= 0.25;","uv.x += 0.25 * float(cascadeId);","#endif","vec2 texelSize = shadowMapSize.zw;","float shadow = 0.0;","for (int x = -1; x <= 1; ++x) {","for (int y = -1; y <= 1; ++y) {","vec2 uv1 = uv + vec2(x, y) * texelSize;","shadow += textureShadowLerp(depth, uv1, zReceiver, bias);","}","}","return (shadow / float(9.0)) * farShadowFade(uv.y);","}","#elif defined(SHADOWED_PLAIN)","float getShadow(in sampler2D depth, in vec2 uv, in float zReceiver, in float bias, in int cascadeId)","{","return textureCompare(depth, uv, zReceiver, bias) * farShadowFade(uv.y);","}","#else","float getShadow(sampler2D depth, vec2 uv, float zReceiver, float bias) { return 0.0; }","#endif","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","uniform sampler2D shadowTex ;","float getBiasedShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in int cascadeId)","{","float bias = shadowBias(normal, lightDirection);","vec3 smc = (sunVertexPosition + vec3(1.0, 1.0, 1.0)) * 0.5;","return getShadow(shadowTex, smc.xy, smc.z, bias, cascadeId);","}","float getWaterBiasedShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in float distortionFactor)","{","vec3 shadowMapCoord = (sunVertexPosition.xyz + vec3(1.0, 1.0, 1.0)) * 0.5;","float bias = shadowBias(normal, lightDirection);","vec2 tc = shadowMapCoord.xy + normal.xy * distortionFactor * 0.1;","return getShadow(shadowTex, tc, shadowMapCoord.z, bias, 0 );","}","void addShadowSpec(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor, inout vec3 totalSpecular)","{","float shadow = getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","sunColor = mix(sunColor, darkColor, shadow);","totalSpecular *= 1.0 - shadow;","}","void addShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor)","{","float shadow = getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","sunColor = mix(sunColor, darkColor, shadow);","}","#else","void addShadowSpec(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor, inout vec3 totalSpecular) {}","void addShadow(in vec3 normal, in vec3 sunVertexPosition, in vec3 lightDirection, in vec3 darkColor, in int cascadeId, inout vec3 sunColor) {}","#endif","#define PI 3.14159265359","float DistributionGGX(vec3 N, vec3 H, float roughness)","{","float a      = roughness*roughness;","float a2     = a*a;","float NdotH  = max(dot(N, H), 0.0);","float NdotH2 = NdotH*NdotH;","float num   = a2;","float denom = (NdotH2 * (a2 - 1.0) + 1.0);","denom = PI * denom * denom;","return num / max(denom, 0.0000001);","}","float GeometrySchlickGGX(float NdotV, float roughness)","{","float r = (roughness + 1.0);","float k = (r*r) / 8.0;","float num   = NdotV;","float denom = NdotV * (1.0 - k) + k;","return num / denom;","}","float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)","{","float NdotV = max(dot(N, V), 0.0);","float NdotL = max(dot(N, L), 0.0);","float ggx2  = GeometrySchlickGGX(NdotV, roughness);","float ggx1  = GeometrySchlickGGX(NdotL, roughness);","return ggx1 * ggx2;","}","vec3 fresnelSchlick(float cosTheta, vec3 F0)","{","float invCosTheta = 1.0 - cosTheta;","float pow5 = invCosTheta * invCosTheta * invCosTheta * invCosTheta * invCosTheta;","return F0 + (1.0 - F0) * pow5;","}","vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)","{","float invCosTheta = 1.0 - cosTheta;","float pow5 = invCosTheta * invCosTheta * invCosTheta * invCosTheta * invCosTheta;","return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow5;","}","vec3 metallicPbrColor(","in float roughness,","in float metallic,","in float translucency,","in vec3 albedo,","in vec3 lightColor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal",")","{","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = dot(normal, lightDirection);","NdotL = mix(max(NdotL, 0.0), abs(NdotL), translucency);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec\t\t  = numerator / max(denominator, 0.000001);","return (kD * albedo / PI + spec) * lightColor * NdotL;","}","vec3 metallicPbrSunColor(","in float roughness,","in float metallic,","in float translucency,","in float emission,","in vec3 albedo,","in vec3 darkColor,","in vec3 lightColor,","in vec3 envmapSunFactor,","in vec3 envmapShadowFactor,","in vec3 envmapSpecularFactor,","in vec3 sunSpecularFactor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in sampler2D specularBrdfLut,","in samplerCube irradianceMap,","in samplerCube envMap,","in int cascadeId",")","{","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","float shadowFactor = 1.0 - getBiasedShadow(normal, sunVertexPosition, lightDirection, cascadeId);","#else","float shadowFactor = 1.0;","#endif","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = dot(normal, lightDirection);","NdotL = mix(max(NdotL, 0.0), abs(NdotL), translucency);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec = numerator / max(denominator, 0.000001);","spec *= sunSpecularFactor * shadowFactor;","vec3 dimLightColor = lightColor * NdotL * shadowFactor;","vec3 diffuseColor = kD * albedo / PI;","vec3 Lo = diffuseColor * max(0.0, 1.0 - emission) * dimLightColor + albedo * emission + spec * dimLightColor;","F = fresnelSchlickRoughness(max(dot(normal, viewDirection), 0.0), F0, roughness);","kD = 1.0 - F;","kD *= 1.0 - metallic;","vec3 irradianceSampleDir = normal.xzy;","irradianceSampleDir.z = -irradianceSampleDir.z;","vec3 irradiance = texture(irradianceMap, irradianceSampleDir).rgb * mix(envmapShadowFactor, envmapSunFactor, NdotL * shadowFactor);","vec3 diffuse = irradiance * albedo;","const float MAX_REFLECTION_LOD = 4.0;","vec3 R = reflect(-viewDirection, normal);","R = R.xzy;","R.z = -R.z;","vec3 prefilteredColor = textureLod(envMap, R,  roughness * MAX_REFLECTION_LOD).rgb;","vec2 brdf  = texture(specularBrdfLut, vec2(max(dot(normal, viewDirection), 0.0), roughness)).rg;","vec3 specular = prefilteredColor * (F * brdf.x + brdf.y) * shadowFactor * envmapSpecularFactor;","vec3 ambient = kD * diffuse + specular;","return Lo + ambient;","}","vec3 waterPbrSunColor(","in float roughness,","in float metallic,","in float specularFactor,","in float distortionFactor,","in vec3 albedo,","in vec3 lightColor,","in vec3 darkColor,","in vec3 envmapSunFactor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in sampler2D specularBrdfLut,","in samplerCube irradianceMap,","in vec3 reflectionColor)","{","#if defined(SHADOWED_PLAIN) || defined(SHADOWED_PCF) || defined(SHADOWED_PCSS)","float shadowFactor = 1.0 - getWaterBiasedShadow(normal, sunVertexPosition, lightDirection, distortionFactor);","#else","float shadowFactor = 1.0;","#endif","vec3 F0 = vec3(0.04);","F0 = mix(F0, albedo, metallic);","vec3 H = normalize(viewDirection + lightDirection);","float NDF = DistributionGGX(normal, H, roughness);","float G   = GeometrySmith(normal, viewDirection, lightDirection, roughness);","vec3 F    = fresnelSchlick(max(dot(H, viewDirection), 0.0), F0);","vec3 kS = F;","vec3 kD = vec3(1.0) - kS;","kD *= 1.0 - metallic;","float NdotL = max(dot(normal, lightDirection), 0.0);","vec3 numerator    = NDF * G * F;","float denominator = 4.0 * max(dot(normal, viewDirection), 0.0) * NdotL;","vec3 spec = numerator / max(denominator, 0.000001);","spec *= shadowFactor * specularFactor;","vec3 dimLightColor = lightColor * NdotL * shadowFactor;","vec3 diffuseColor = kD * albedo / PI;","vec3 Lo = diffuseColor * dimLightColor + spec * dimLightColor;","F = fresnelSchlickRoughness(max(dot(normal, viewDirection), 0.0), F0, roughness);","kD = 1.0 - F;","kD *= 1.0 - metallic;","vec3 irradianceSampleDir = normal.xzy;","irradianceSampleDir.z = -irradianceSampleDir.z;","vec3 irradiance = texture(irradianceMap, irradianceSampleDir).rgb * mix(darkColor, envmapSunFactor, NdotL * shadowFactor);","vec3 diffuse = irradiance * albedo;","const float MAX_REFLECTION_LOD = 4.0;","vec3 R = reflect(-viewDirection, normal);","R = R.xzy;","R.z = -R.z;","vec3 prefilteredColor = reflectionColor;","vec2 brdf  = texture(specularBrdfLut, vec2(max(dot(normal, viewDirection), 0.0), roughness)).rg;","vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);","specular = mix(specular * darkColor, specular, shadowFactor) * albedo;","vec3 ambient = kD * diffuse + specular;","return Lo + ambient;","}","vec3 blinnPhongColor(","in float specular,","in float specularPower,","in float translucency,","in float emission,","in vec3 albedo,","in vec3 darkColor,","in vec3 lightColor,","in vec3 viewDirection,","in vec3 lightDirection,","in vec3 normal,","in vec3 sunVertexPosition,","in int cascadeId",")","{","vec3 reflection = -reflect(lightDirection, normal);","float fRdotV = max(0.0, dot(normalize(reflection), viewDirection));","vec3 totalSpecular = lightColor * pow(fRdotV, specularPower) * specular;","float LDdotN = dot(lightDirection, normal);","float lightIntensity = clamp(mix(max(LDdotN, 0.0), abs(LDdotN), translucency), 0.0, 1.0);","vec3 sunColor = mix(darkColor, lightColor, lightIntensity);","addShadowSpec(normal, sunVertexPosition, lightDirection, darkColor, cascadeId, sunColor, totalSpecular);","vec3 outDiffuseColor = albedo * sunColor;","outDiffuseColor = outDiffuseColor * max(0.0, 1.0 - emission) + albedo * emission;","return outDiffuseColor + totalSpecular;","}","const float pi = 3.14159265359;","const float halfPi = 1.57079632679;","uniform sampler2D colorTex ;","uniform sampler2D normalTex ;","uniform vec3 lightDirection;","uniform float textureScale;","uniform vec3 darkColor;","uniform vec3 lightColor;","uniform vec2 tileCoordMul;","uniform float specularFactor;","uniform float specularPower;","uniform float metalness;","uniform float zGridScale;","uniform float normalZScale;","uniform vec4 tileSizes;","#ifndef SUBMARINE_SAMPLING","uniform vec3 submarineColorMultiplier;","uniform vec3 submarineBottomDiffWl;","#define submarineBottom (submarineBottomDiffWl.x)","#define submarineDiff (submarineBottomDiffWl.y)","#define waterLevel (submarineBottomDiffWl.z)","#endif","uniform sampler2D specularRoughnessTex ;","uniform sampler2D combineTex ;","smooth in vec4 _vertexWeights;","smooth in vec4 _tcx;","smooth in vec4 _tcy;","smooth in vec4 _tcyInv;","smooth in vec4 _n;","smooth in float transitionSharpness;","#if !defined(DEFERRED) || defined(FOG_OF_WAR)","smooth in vec4 sunVertexPosition;","#endif","#if !defined(DEFERRED)","smooth in vec3 viewDirection;","#endif","#ifdef TERRAIN_COLOR_PRIORITY","#define COLOR_SIZE 2","#else","#define COLOR_SIZE 1","#endif","#ifdef TERRAIN_STRENGTH","smooth in vec3 colR[COLOR_SIZE];","smooth in vec3 colG[COLOR_SIZE];","smooth in vec3 colB[COLOR_SIZE];","#else","smooth in vec3 colmul[COLOR_SIZE];","#endif","#define fragCameraDistance _n.w","#define geomNormal _n.xyz","#define positionZ _vertexWeights.w","#define vertexWeights _vertexWeights.xyz","vec3 linNormalizeWeights(in vec3 v)","{","float d = dot(v, vec3(1.0));","return (d < 0.004) ? vertexWeights : v / d;","}","#ifdef TERRAIN_STRENGTH","vec3 getWeights(in mat3 bas)","{","return linNormalizeWeights(vertexWeights * vec3(bas[0].b, bas[1].b, bas[2].b));","}","vec3 getFragColor(in float fragBrightness, in vec3 weights, in float alpha, in vec3 vertexWeightsInv)","{","#ifdef TERRAIN_COLOR_PRIORITY","vec3 cr0 = colR[0] * vertexWeightsInv;","vec3 cg0 = colG[0] * vertexWeightsInv;","vec3 cb0 = colB[0] * vertexWeightsInv;","vec3 cr1 = colR[1] * vertexWeightsInv;","vec3 cg1 = colG[1] * vertexWeightsInv;","vec3 cb1 = colB[1] * vertexWeightsInv;","vec3 v0color = mix(vec3(cr0[0], cg0[0], cb0[0]), vec3(cr1[0], cg1[0], cb1[0]), alpha);","vec3 v1color = mix(vec3(cr0[1], cg0[1], cb0[1]), vec3(cr1[1], cg1[1], cb1[1]), alpha);","vec3 v2color = mix(vec3(cr0[2], cg0[2], cb0[2]), vec3(cr1[2], cg1[2], cb1[2]), alpha);","return fragBrightness * (v0color * weights[0] + v1color * weights[1] + v2color * weights[2]);","#else","vec3 cr = colR[0] * vertexWeightsInv;","vec3 cg = colG[0] * vertexWeightsInv;","vec3 cb = colB[0] * vertexWeightsInv;","return fragBrightness * (","vec3(cr[0], cg[0], cb[0]) * weights[0] +","vec3(cr[1], cg[1], cb[1]) * weights[1] +","vec3(cr[2], cg[2], cb[2]) * weights[2]",");","#endif","}","#else","vec3 getWeights(in mat3 bas)","{","return vertexWeights;","}","vec3 getFragColor(in float fragBrightness, in vec3 weights, in float alpha, in vec3 vertexWeightsInv)","{","#ifdef TERRAIN_COLOR_PRIORITY","return fragBrightness * mix(colmul[0], colmul[1], alpha);","#else","return fragBrightness * colmul[0];","#endif","}","#endif","#ifdef TERRAIN_GOOD","mat3 getBas(","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy)","{","vec3 horPlane0 = vec3(textureGrad(colorTex, tc0, ctc3dx, ctc3dy).r, textureGrad(combineTex, tc0, ctc3dx, ctc3dy).rg);","vec3 horPlane1 = vec3(textureGrad(colorTex, tc1, ctc3dx, ctc3dy).r, textureGrad(combineTex, tc1, ctc3dx, ctc3dy).rg);","vec3 horPlane2 = vec3(textureGrad(colorTex, tc2, ctc3dx, ctc3dy).r, textureGrad(combineTex, tc2, ctc3dx, ctc3dy).rg);","return mat3(","vec3(textureGrad(colorTex, vec2(zx[0], tc0.y), ctc1dx, ctc1dy).r, textureGrad(combineTex, vec2(zx[0], tc0.y), ctc1dx, ctc1dy).rg) * triplanarBlend.x +","vec3(textureGrad(colorTex, vec2(tc0.x, zy[0]), ctc2dx, ctc2dy).r, textureGrad(combineTex, vec2(tc0.x, zy[0]), ctc2dx, ctc2dy).rg) * triplanarBlend.y +","horPlane0 * triplanarBlend.z,","vec3(textureGrad(colorTex, vec2(zx[1], tc1.y), ctc1dx, ctc1dy).r, textureGrad(combineTex, vec2(zx[1], tc1.y), ctc1dx, ctc1dy).rg) * triplanarBlend.x +","vec3(textureGrad(colorTex, vec2(tc1.x, zy[1]), ctc2dx, ctc2dy).r, textureGrad(combineTex, vec2(tc1.x, zy[1]), ctc2dx, ctc2dy).rg) * triplanarBlend.y +","horPlane1 * triplanarBlend.z,","vec3(textureGrad(colorTex, vec2(zx[2], tc2.y), ctc1dx, ctc1dy).r, textureGrad(combineTex, vec2(zx[2], tc2.y), ctc1dx, ctc1dy).rg) * triplanarBlend.x +","vec3(textureGrad(colorTex, vec2(tc2.x, zy[2]), ctc2dx, ctc2dy).r, textureGrad(combineTex, vec2(tc2.x, zy[2]), ctc2dx, ctc2dy).rg) * triplanarBlend.y +","horPlane2 * triplanarBlend.z",");","}","float getBrightness(in mat3 bas, in vec3 weights)","{","float fragBrightness =","bas[0].r * weights[0] +","bas[1].r * weights[1] +","bas[2].r * weights[2];","return fragBrightness;","}","float calcSpecular(in vec3 spec, in vec3 weights)","{","float fragSpecular = dot(spec, weights);","return fragSpecular;","}","float getAlpha(in mat3 bas, in vec3 weights)","{","#ifdef TERRAIN_COLOR_PRIORITY","float fragAlpha =","bas[0].g * weights[0] +","bas[1].g * weights[1] +","bas[2].g * weights[2];","return fragAlpha;","#else","return 0.0;","#endif","}","vec3 getNormal(","in vec3 geometryNormal,","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy,","in vec3 weights)","{","vec2 hp0 = textureGrad(normalTex, tc0, ctc3dx, ctc3dy).NM_XY * 2.0 - 1.0;","vec2 hp1 = textureGrad(normalTex, tc1, ctc3dx, ctc3dy).NM_XY * 2.0 - 1.0;","vec2 hp2 = textureGrad(normalTex, tc2, ctc3dx, ctc3dy).NM_XY * 2.0 - 1.0;","vec2 p0xs = textureGrad(normalTex, vec2(zx[0], tc0.y), ctc1dx, ctc1dy).NM_XY * 2.0 - 1.0;","vec2 p1xs = textureGrad(normalTex, vec2(zx[1], tc1.y), ctc1dx, ctc1dy).NM_XY * 2.0 - 1.0;","vec2 p2xs = textureGrad(normalTex, vec2(zx[2], tc2.y), ctc1dx, ctc1dy).NM_XY * 2.0 - 1.0;","vec2 p0ys = textureGrad(normalTex, vec2(tc0.x, zy[0]), ctc2dx, ctc2dy).NM_XY * 2.0 - 1.0;","vec2 p1ys = textureGrad(normalTex, vec2(tc1.x, zy[1]), ctc2dx, ctc2dy).NM_XY * 2.0 - 1.0;","vec2 p2ys = textureGrad(normalTex, vec2(tc2.x, zy[2]), ctc2dx, ctc2dy).NM_XY * 2.0 - 1.0;","vec2 nm0xy =","(hp0 * weights[0] +","hp1 * weights[1] +","hp2 * weights[2]);","vec2 nm1xy =","(p0xs * weights[0] +","p1xs * weights[1] +","p2xs * weights[2]);","vec2 nm2xy =","(p0ys * weights[0] +","p1ys * weights[1] +","p2ys * weights[2]);","vec3 nm0 = vec3(nm0xy, sqrt(max(0.0, 1.0 - dot(nm0xy, nm0xy))));","vec3 nm1 = vec3(nm1xy, sqrt(max(0.0, 1.0 - dot(nm1xy, nm1xy))));","vec3 nm2 = vec3(nm2xy, sqrt(max(0.0, 1.0 - dot(nm2xy, nm2xy))));","vec3 s = sign(geometryNormal);","nm0 *= triplanarBlend[2];","nm1 = vec3(nm1.z * s[0], nm1.y, nm1.x) * triplanarBlend[0];","nm2 = vec3(nm2.x, nm2.z * s[1], nm2.y) * triplanarBlend[1];","vec3 result = nm0 + nm1 + nm2;","result.z *= normalZScale;","return normalize(result);","}","vec3 getSpecularRoughness(","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy)","{","float horPlane0 = textureGrad(specularRoughnessTex, tc0, ctc3dx, ctc3dy).r;","float horPlane1 = textureGrad(specularRoughnessTex, tc1, ctc3dx, ctc3dy).r;","float horPlane2 = textureGrad(specularRoughnessTex, tc2, ctc3dx, ctc3dy).r;","float v0 = dot(vec3(","textureGrad(specularRoughnessTex, vec2(zx[0], tc0.y), ctc1dx, ctc1dy).r,","textureGrad(specularRoughnessTex, vec2(tc0.x, zy[0]), ctc2dx, ctc2dy).r,","horPlane0), triplanarBlend);","float v1 = dot(vec3(","textureGrad(specularRoughnessTex, vec2(zx[1], tc1.y), ctc1dx, ctc1dy).r,","textureGrad(specularRoughnessTex, vec2(tc1.x, zy[1]), ctc2dx, ctc2dy).r,","horPlane1), triplanarBlend);","float v2 = dot(vec3(","textureGrad(specularRoughnessTex, vec2(zx[2], tc2.y), ctc1dx, ctc1dy).r,","textureGrad(specularRoughnessTex, vec2(tc2.x, zy[2]), ctc2dx, ctc2dy).r,","horPlane2), triplanarBlend);","return vec3(v0, v1, v2);","}","#elif defined TERRAIN_BAD","mat3 getBas(","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy)","{","return mat3(","vec3(textureGrad(colorTex, tc0, ctc3dx, ctc3dy).r, textureGrad(combineTex, tc0, ctc3dx, ctc3dy).rg),","vec3(textureGrad(colorTex, tc1, ctc3dx, ctc3dy).r, textureGrad(combineTex, tc1, ctc3dx, ctc3dy).rg),","vec3(textureGrad(colorTex, tc2, ctc3dx, ctc3dy).r, textureGrad(combineTex, tc2, ctc3dx, ctc3dy).rg)",");","}","vec3 getSpecularRoughness(","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy)","{","return vec3(","textureGrad(specularRoughnessTex, tc0, ctc3dx, ctc3dy).r,","textureGrad(specularRoughnessTex, tc1, ctc3dx, ctc3dy).r,","textureGrad(specularRoughnessTex, tc2, ctc3dx, ctc3dy).r",");","}","float getBrightness(in mat3 bas, in vec3 weights)","{","return bas[0].r * weights[0] + bas[1].r * weights[1] + bas[2].r * weights[2];","}","float calcSpecular(in vec3 spec, in vec3 weights)","{","return dot(spec, weights);","}","float getAlpha(in mat3 bas, in vec3 weights)","{","#ifdef TERRAIN_COLOR_PRIORITY","return bas[0].g * weights[0] + bas[1].g * weights[1] + bas[2].g * weights[2];","#else","return 0.0;","#endif","}","vec3 getNormal(","in vec3 geometryNormal,","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy,","in vec3 weights)","{","return geometryNormal;","}","#else","mat3 getBas(","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy)","{","return mat3(0.0);","}","float getBrightness(in mat3 bas, in vec3 weigths) { return 0.0; }","float calcSpecular(in vec3 spec, in vec3 weights) { return 0.0; }","float getAlpha(in mat3 bas, in vec3 weigths) { return 0.0; }","vec3 getNormal(","in vec3 geometryNormal,","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy,","in vec3 weights) { return vec3(0.0); }","vec3 getSpecularRoughness(","in vec3 triplanarBlend,","in vec3 zx,","in vec3 zy,","in vec2 tc0,","in vec2 tc1,","in vec2 tc2,","in vec2 ctc1dx,","in vec2 ctc1dy,","in vec2 ctc2dx,","in vec2 ctc2dy,","in vec2 ctc3dx,","in vec2 ctc3dy)","{","return vec3(0.0);","}","#endif","layout(location = 0) out vec4 drawBuffer0;","#define outFragColor drawBuffer0","#ifdef DEFERRED","layout(location = 1) out vec4 drawBuffer1;","layout(location = 2) out vec4 drawBuffer2;","#define albedo (drawBuffer0.rgb)","#define outFragNormal (drawBuffer1.rgb)","#define outSpecular (drawBuffer2.r)","#define outRoughness (drawBuffer2.r)","#define outEmission (drawBuffer2.g)","#define outSpecularPower (drawBuffer2.b)","#define outMetalness (drawBuffer2.b)","#define outTranslucency (drawBuffer2.a)","#else","#ifdef FOG_OF_WAR_POSTPROCESS","layout(location = 2) out vec4 drawBuffer2;","#define outFowBuffer (drawBuffer2.r)","#endif","#endif","void main()","{","#ifdef OVERDRAW_FULL","outFragColor = vec4(0.1, 0.0, 0.0, 1.0);","#else","vec3 vertexWeightsInv = min(1.0 / vertexWeights, 1e16);","vec3 tcx = (_tcx.xyz * vertexWeightsInv);","vec3 tcy = (_tcy.xyz * vertexWeightsInv);","vec3 tcyInv = (_tcyInv.xyz * vertexWeightsInv);","vec2 climateTexCoord = vec2(fract(_tcx.w), fract(_tcy.w)) * tileCoordMul;","vec2 tc0 = vec2(tcx[0], tcy[0]) + climateTexCoord;","vec2 tc1 = vec2(tcx[1], tcy[1]) + climateTexCoord;","vec2 tc2 = vec2(tcx[2], tcy[2]) + climateTexCoord;","float zGrid = positionZ * zGridScale;","vec2 z = fract(zGrid) * tileCoordMul;","vec3 zx = tcx + vec3(z.x);","vec3 zy = tcyInv - vec3(z.y);","vec3 triplanarBlend = abs(normalize(geomNormal));","triplanarBlend = pow(normalize(triplanarBlend * triplanarBlend), vec3(transitionSharpness));","triplanarBlend /= dot(triplanarBlend, vec3(1.0));","vec2 continousTc1 = vec2(zGrid, _tcy.w) * tileCoordMul;","vec2 continousTc2 = vec2(_tcx.w, zGrid) * tileCoordMul;","vec2 continousTc3 = vec2(_tcx.w, _tcy.w) * tileCoordMul;","vec2 ctc1dx = dFdx(continousTc1);","vec2 ctc1dy = dFdy(continousTc1);","vec2 ctc2dx = dFdx(continousTc2);","vec2 ctc2dy = dFdy(continousTc2);","vec2 ctc3dx = dFdx(continousTc3);","vec2 ctc3dy = dFdy(continousTc3);","mat3 bas = getBas(","triplanarBlend,","zx,","zy,","tc0,","tc1,","tc2,","ctc1dx,","ctc1dy,","ctc2dx,","ctc2dy,","ctc3dx,","ctc3dy",");","vec3 weights = getWeights(bas);","float fragBrightness = getBrightness(bas, weights);","vec3 specularPerTile = getSpecularRoughness(","triplanarBlend,","zx,","zy,","tc0,","tc1,","tc2,","ctc1dx,","ctc1dy,","ctc2dx,","ctc2dy,","ctc3dx,","ctc3dy",");","#ifdef PBR_METALLIC","float fragRoughness = calcSpecular(specularPerTile, weights);","#else","float fragSpecular = calcSpecular(specularPerTile, weights) * specularFactor;","#endif","vec3 nn = normalize(geomNormal);","vec3 n = getNormal(","nn,","triplanarBlend,","zx,","zy,","tc0,","tc1,","tc2,","ctc1dx,","ctc1dy,","ctc2dx,","ctc2dy,","ctc3dx,","ctc3dy,","weights",");","float fragAlpha = getAlpha(bas, weights);","vec3 fragColor = getFragColor(fragBrightness, weights, fragAlpha, vertexWeightsInv);","#ifndef SUBMARINE_SAMPLING","float submarineColorInterp = 1.0 - clamp((positionZ - submarineBottom) / submarineDiff, 0.0, 1.0);","const float submarineColorTransitionRange = 4.0;","submarineColorInterp *= 1.0 - mapTo01(positionZ, waterLevel - submarineColorTransitionRange, waterLevel);","fragColor *= mix(vec3(1.0), submarineColorMultiplier, submarineColorInterp);","#endif","#ifdef DEFERRED","albedo = fragColor;","n += vec3(1.0);","n *= 0.5f;","outFragNormal = n;","#ifdef PBR_METALLIC","outRoughness = fragRoughness;","outMetalness = metalness;","#else","outSpecular = 1.0 / (1.0 + fragSpecular);","outSpecularPower = specularPower;","#endif","outEmission = 1.0;","outTranslucency = 0.0;","#else","#ifdef PBR_METALLIC","outFragColor.rgb = metallicPbrColor(fragRoughness, metalness, 0.0, fragColor, lightColor, normalize(viewDirection), lightDirection, n);","#else","outFragColor.rgb = fragColor;","float lightIntensity = clamp(dot(n, lightDirection), 0.0, 1.0);","vec3 reflection = -reflect(normalize(lightDirection), n);","float fRdotV = max(0.0, dot(normalize(reflection), normalize(viewDirection)));","vec3 totalSpecular = lightColor * pow(fRdotV, specularPower) * fragSpecular;","vec3 sunColor = mix(darkColor, lightColor, lightIntensity);","addShadowSpec(n, sunVertexPosition.xyz, lightDirection, darkColor, 0 , sunColor, totalSpecular);","outFragColor.rgb *= sunColor;","outFragColor.rgb += totalSpecular;","#endif","outFragColor.a = 1.0;","outFragColor.rgb = addFog(outFragColor.rgb, fragCameraDistance);","float fow = getFogOfWarFactor(vec2(_tcyInv.w, sunVertexPosition.w));","outFragColor.rgb *= fow;","#ifdef FOG_OF_WAR_POSTPROCESS","outFowBuffer = fow;","#endif","#endif","#ifdef OVERDRAW_ALPHA","outFragColor = vec4(0.1, 0.0, 0.0, 1.0);","#endif","#endif","}"],"vertex":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","vec3 unpackRgNormal(in vec2 xy)","{","xy = xy * 2.0 - 1.0;","return vec3(xy, sqrt(max(0.0, 1.0 - dot(xy, xy))));","}","vec3 sampleNormalmap(in sampler2D tex, in vec2 tc)","{","return unpackRgNormal(SAMPLE_2D(tex, tc).NM_XY);","}","vec3 downsample13(in sampler2D tex, in vec2 tc, in vec2 texelSize)","{","vec3 s1  = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0, -1.0)).rgb;","vec3 s2  = SAMPLE_2D(tex, tc + texelSize * vec2( 0.0, -1.0)).rgb;","vec3 s3  = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0, -1.0)).rgb;","vec3 s4  = SAMPLE_2D(tex, tc + texelSize * vec2(-0.5, -0.5)).rgb;","vec3 s5  = SAMPLE_2D(tex, tc + texelSize * vec2( 0.5, -0.5)).rgb;","vec3 s6  = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0,  0.0)).rgb;","vec3 s7  = SAMPLE_2D(tex, tc).rgb;","vec3 s8  = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0,  0.0)).rgb;","vec3 s9  = SAMPLE_2D(tex, tc + texelSize * vec2(-0.5,  0.5)).rgb;","vec3 s10 = SAMPLE_2D(tex, tc + texelSize * vec2( 0.5,  0.5)).rgb;","vec3 s11 = SAMPLE_2D(tex, tc + texelSize * vec2(-1.0,  1.0)).rgb;","vec3 s12 = SAMPLE_2D(tex, tc + texelSize * vec2( 0.0,  1.0)).rgb;","vec3 s13 = SAMPLE_2D(tex, tc + texelSize * vec2( 1.0,  1.0)).rgb;","return","(s4 + s5 + s9 + s10) * 0.125 +","(s1 + s2 + s7 + s6) * 0.03125 +","(s2 + s3 + s8 + s7) * 0.03125 +","(s6 + s7 + s12 + s11) * 0.03125 +","(s7 + s8 + s13 + s12) * 0.03125;","}","vec3 downsample4(in sampler2D tex, in vec2 tc, in vec2 texelSize)","{","vec4 displacement = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);","vec3 s =","SAMPLE_2D(tex, tc + displacement.xy).rgb +","SAMPLE_2D(tex, tc + displacement.zy).rgb +","SAMPLE_2D(tex, tc + displacement.xw).rgb +","SAMPLE_2D(tex, tc + displacement.zw).rgb;","return s * 0.25;","}","vec3 magTent(in sampler2D tex, in vec2 uv, in vec2 texelSize, in float sampleScale)","{","vec4 displacement = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;","vec3 result =","SAMPLE_2D(tex, uv - displacement.xy).rgb +","SAMPLE_2D(tex, uv - displacement.wy).rgb * 2.0 +","SAMPLE_2D(tex, uv - displacement.zy).rgb +","SAMPLE_2D(tex, uv + displacement.zw).rgb * 2.0 +","SAMPLE_2D(tex, uv).rgb * 4.0 +","SAMPLE_2D(tex, uv + displacement.xw).rgb * 2.0 +","SAMPLE_2D(tex, uv + displacement.zy).rgb +","SAMPLE_2D(tex, uv + displacement.wy).rgb * 2.0 +","SAMPLE_2D(tex, uv + displacement.xy).rgb;","return result * 0.0625;","}","vec3 magBox(in sampler2D tex, in vec2 tc, in vec2 texelSize, in float sampleScale)","{","vec4 displacement = texelSize.xyxy * vec4(-0.5, -0.5, 0.5, 0.5) * sampleScale;","vec3 s =","SAMPLE_2D(tex, (tc + displacement.xy)).rgb +","SAMPLE_2D(tex, (tc + displacement.zy)).rgb +","SAMPLE_2D(tex, (tc + displacement.xw)).rgb +","SAMPLE_2D(tex, (tc + displacement.zw)).rgb;","return s * 0.25;","}","vertAttrib(0, vec2, vertexData);","#ifdef INSTANCED","vertAttrib(1, vec2, patchOrigin);","#endif","uniform mat4 viewProjectionMatrix;","uniform mat4 sunMatrix;","uniform vec2 heightTerrainScale;","uniform vec2 terrainSize;","uniform float textureScale;","uniform vec4 tilesCount;","uniform vec3 viewCameraPosition;","uniform vec4 tileSizes;","uniform float triplanarTransitionSharpnessMap[64];","#if !defined(INSTANCED)","uniform vec2 patchOrigin;","#endif","#define atlasTiles (tilesCount.xy)","#define invAtlasTiles (tilesCount.zw)","#define paddedTileSizeX (tileSizes.x)","#define paddedTileSizeY (tileSizes.y)","#define padSizeX (tileSizes.z)","#define padSizeY (tileSizes.w)","#ifdef FOG_OF_WAR","uniform vec4 fowMapScalePosition;","#endif","#define heightScale heightTerrainScale.x","#define terrainScale heightTerrainScale.y","uniform sampler2D heightTex ;","uniform sampler2D colorClimateTex ;","uniform sampler2D normalMap ;","uniform sampler2D color2Tex ;","smooth out vec4 _vertexWeights;","smooth out vec4 _tcx;","smooth out vec4 _tcy;","smooth out vec4 _tcyInv;","smooth out vec4 _n;","smooth out float transitionSharpness;","#if !defined(DEFERRED) || defined(FOG_OF_WAR)","smooth out vec4 sunVertexPosition;","#endif","#if !defined(DEFERRED)","smooth out vec3 viewDirection;","#endif","#ifdef TERRAIN_COLOR_PRIORITY","#define COLOR_SIZE 2","#else","#define COLOR_SIZE 1","#endif","#ifdef TERRAIN_STRENGTH","smooth out vec3 colR[COLOR_SIZE];","smooth out vec3 colG[COLOR_SIZE];","smooth out vec3 colB[COLOR_SIZE];","#else","smooth out vec3 colmul[COLOR_SIZE];","#endif","#define fragCameraDistance _n.w","#define geomNormal _n.xyz","#define positionZ _vertexWeights.w","#define vertexWeights _vertexWeights.xyz","void main()","{","vec2 patchPosition = vertexData + patchOrigin;","patchPosition = min(patchPosition, terrainSize - vec2(1.0));","vec2 vertexTexCoord = (patchPosition + 0.5) / terrainSize;","vec3 position = vec3(patchPosition * terrainScale, texture(heightTex, vertexTexCoord).r * heightScale);","gl_Position = viewProjectionMatrix * vec4(position, 1.0);","#ifdef FOG_OF_WAR","vec2 fowTc = position.xy * fowMapScalePosition.xy + fowMapScalePosition.zw;","_tcyInv.w = fowTc.x;","sunVertexPosition.w = fowTc.y;","#endif","vec4 colorClimate = texture(colorClimateTex, vertexTexCoord);","vec2 odd = fract(vertexData / 2.0) * 2.0;","vec2 even = vec2(1.0) - odd;","vertexWeights =","clamp(odd.y * even.x + even.y * odd.x, 0.0, 1.0) * vec3(1.0, 0.0, 0.0) +","(even.y * even.x)\t\t\t\t\t\t\t\t * vec3(0.0, 1.0, 0.0) +","(odd.y * odd.x)\t\t\t\t\t\t\t\t * vec3(0.0, 0.0, 1.0);","#ifdef TERRAIN_STRENGTH","colR[0] = colorClimate.r * vertexWeights;","colG[0] = colorClimate.g * vertexWeights;","colB[0] = colorClimate.b * vertexWeights;","#ifdef TERRAIN_COLOR_PRIORITY","vec3 color2 = texture(color2Tex, vertexTexCoord).rgb;","colR[1] = color2.r * vertexWeights;","colG[1] = color2.g * vertexWeights;","colB[1] = color2.b * vertexWeights;","#endif","#else","colmul[0] = colorClimate.rgb;","#ifdef TERRAIN_COLOR_PRIORITY","colmul[1] = texture(color2Tex, vertexTexCoord).rgb;","#endif","#endif","float climate = round(colorClimate.a * 255.0);","transitionSharpness = triplanarTransitionSharpnessMap[min(int(climate), 63)];","float tileY = floor(climate * invAtlasTiles.x);","float tileX = climate - tileY / invAtlasTiles.x;","_tcx.xyz = vertexWeights * (tileX * paddedTileSizeX + padSizeX);","_tcy.xyz = vertexWeights * (tileY * paddedTileSizeY + padSizeY);","_tcyInv.xyz = vertexWeights * ((tileY + 1.0) * paddedTileSizeY - padSizeY);","_tcx.w = patchPosition.x * textureScale;","_tcy.w = patchPosition.y * textureScale;","_n.xyz = sampleNormalmap(normalMap, vertexTexCoord);","#ifdef DEFERRED","#else","sunVertexPosition.xyz = (sunMatrix * vec4(position, 1.0)).xyz;","fragCameraDistance = distance(viewCameraPosition, position);","viewDirection = normalize(viewCameraPosition - position);","#endif","positionZ = position.z;","}"]}}
