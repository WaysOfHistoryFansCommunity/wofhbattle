{"meta":{"feedback_varyings":null,"interface_block_bindings":[[0,"Skeleton0"],[4,"BindPose"],[5,"Skeleton5"]],"sampler_default_values":[["diffuseTex",0],["dissolveTex",5]],"shader_parameters":[["vertex","float","attachmentBoneIndex",1],["vertex","vec4","attachmentDisplacementScale",1],["vertex","mat3x4","attachmentMatrix",1],["vertex","mat3x4","boneMatrices3x4",0],["fragment","sampler2D","diffuseTex",1],["fragment","bool","dissolveEnabled",1],["fragment","sampler2D","dissolveTex",1],["fragment","float","dissolveThreshold",1],["vertex","int","geometryType",1],["fragment","int","instanceIdx",1],["vertex","int","instanceIdx",1],["vertex","float","interpolationParameter",1],["vertex","mat4","modelViewProjection",1],["vertex","ivec2","startIndices",1],["fragment","vec2","texDisplacement",1]],"vertex_attributes":[[0,"vec3","vertexAttribute0"],[1,"vec4","vertexAttribute1"],[2,"vec3","vertexAttribute2"],[6,"vec3","vertexAttribute6"],[10,"vec2","texCoord"],[11,"uvec2","vertexAttribute11"]]},"stages":{"fragment":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#ifdef BATCHED","#extension GL_ARB_bindless_texture: require","#endif","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#ifdef FOG_OF_WAR_POSTPROCESS","#define DECLARE_FRAGCOLOR layout(location = 0) out vec4 outFragColor; layout(location = 2) out vec4 outFowBuffer;","#else","#define DECLARE_FRAGCOLOR layout(location = 0) out vec4 outFragColor;","#endif","#define outFragDepth gl_FragDepth","#ifdef BATCHED","struct InstancingBuffer","{","vec4 texDisplacementDissolveParams;","uvec4 diffuseMap;","};","layout(std140, binding = 7) restrict readonly buffer InstancesFrag { InstancingBuffer instances[]; };","uniform int instanceIdx;","flat in ivec2 instancingVaryingData;","#define instanceId instancingVaryingData.x","#define texDisplacement (instances[instanceIdx + instanceId].texDisplacementDissolveParams.xy)","#define dissolveThreshold (instances[instanceIdx + instanceId].texDisplacementDissolveParams.z)","#define dissolveEnabled (bool(instances[instanceIdx + instanceId].texDisplacementDissolveParams.w == 1.0))","#define diffuseTex sampler2D(instances[instanceIdx + instanceId].diffuseMap.xy)","#else","uniform sampler2D diffuseTex ;","uniform bool dissolveEnabled;","uniform float dissolveThreshold;","uniform vec2 texDisplacement;","#endif","smooth in vec2 fragTexCoord;","uniform sampler2D dissolveTex ;","void dissolveHole()","{","if (!dissolveEnabled) return;","float dissolve = texture(dissolveTex, fragTexCoord).r;","float aboveThreshold = step(dissolveThreshold, dissolve);","if (aboveThreshold == 0.0) discard;","}","void main()","{","if (texture(diffuseTex, fragTexCoord + texDisplacement).a < 0.5) discard;","dissolveHole();","}"],"vertex":["#version 300 es","precision mediump float;","precision mediump sampler3D;","#ifdef SSBO_SKELETON","#extension GL_ARB_shader_storage_buffer_object: require","#endif","#define transformFeedback(varName)","#if (__VERSION__ >= 330) || (__VERSION__ == 300)","#define vertAttrib(Num, Type, Name) layout(location = Num) in Type Name","#else","#define vertAttrib(Num, Type, Name) attribute Type Name","#endif","#if __VERSION__ <= 120","#define VAR_SMOOTH_IN(type, name) varying type name","#define VAR_FLAT_IN(type, name) varying type name","#define VAR_SMOOTH_OUT(type, name) varying type name","#define VAR_FLAT_OUT(type, name) varying type name","#define SAMPLE_2D(_smplr, _tc) (texture2D(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (texture2D(_smplr, _tc))","#define SAMPLE_CUBE(_smplr, _tc) (textureCube(_smplr, _tc))","#else","#define VAR_SMOOTH_IN(type, name) smooth in type name","#define VAR_FLAT_IN(type, name) flat in type name","#define VAR_SMOOTH_OUT(type, name) smooth out type name","#define VAR_FLAT_OUT(type, name) flat out type name","#define SAMPLE_2D(_smplr, _tc) (texture(_smplr, _tc))","#define SAMPLE_2D_GRAD(_smplr, _tc, Fx, Fy) (textureGrad(_smplr, _tc, dFdx(Fx), dFdy(Fy)))","#define SAMPLE_CUBE(_smplr, _tc) (texture(_smplr, _tc))","#endif","#if (__VERSION__ < 130) || defined(NO_RG)","#define NM_XY ra","#else","#define NM_XY rg","#endif","#ifndef MAX_BONES","#define MAX_BONES 1","#endif","#ifdef BATCHED","struct InstancingBuffer","{","ivec4 startIndices;","mat4 modelTransformation;","};","uniform int instanceIdx;","layout(std140, row_major, binding = 6) restrict readonly buffer Instances { InstancingBuffer instances[]; };","flat out ivec2 instancingVaryingData;","#define instanceId instancingVaryingData.x","#define attachmentBoneIndex (instances[instanceIdx + gl_InstanceID].startIndices[2])","#define modelViewProjection (instances[instanceIdx + gl_InstanceID].modelTransformation)","layout(std140, binding = 0) restrict readonly buffer BindInverse { mat3x4 bindInverseMatrices[]; };","layout(std140, binding = 4) restrict readonly buffer BoneMatrices { mat3x4 boneMatrices[]; };","#else","#ifdef SSBO_SKELETON","uniform ivec2 startIndices;","#define matricesStartIndex startIndices.x","#define boneMatrixStartIndex startIndices.y","layout(std140, binding = 0) restrict readonly buffer BindInverse { mat3x4 bindInverseMatrices[]; };","mat3x4 getBindInverse(in int index) { return bindInverseMatrices[matricesStartIndex + index]; }","layout(std140, binding = 4) restrict readonly buffer BoneMatrices { mat3x4 boneMatrices[]; };","mat3x4 getBoneMatrix(in int idx) { return boneMatrices[boneMatrixStartIndex + idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices[boneMatrixStartIndex + idx - 1]; }","#elif defined(UBO_AVAILABLE)","layout(std140) uniform Skeleton0","{","mat3x4 boneMatrices[MAX_BONES];","};","mat3x4 getBoneMatrix(in int idx) { return boneMatrices[idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices[idx - 1]; }","layout(std140) uniform BindPose","{","mat3x4 bindInverse[MAX_BONES];","};","mat3x4 getBindInverse(in int index) { return bindInverse[index]; }","#elif defined(CPU_SKELETON)","uniform mat3x4 boneMatrices3x4[MAX_BONES];","mat3x4 getBoneMatrix(in int idx) { return boneMatrices3x4[idx]; }","mat3x4 calcBoneMatrix(in int idx) { return boneMatrices3x4[idx - 1]; }","#else","mat3x4 getBoneMatrix(in int idx) { return mat3x4(0.0); }","mat3x4 calcBoneMatrix(in int idx) { return mat3x4(0.0); }","#endif","uniform float attachmentBoneIndex;","uniform mat4 modelViewProjection;","#endif","void translate(inout mat4 m, in vec3 v)","{","m[0].xyz += m[0][3] * v;","m[1].xyz += m[1][3] * v;","m[2].xyz += m[2][3] * v;","m[3].xyz += m[3][3] * v;","}","void matrixScale(inout mat4 m, in float s)","{","m[0][0] *= s;","m[0][1] *= s;","m[0][2] *= s;","m[0][3] *= s;","m[1][0] *= s;","m[1][1] *= s;","m[1][2] *= s;","m[1][3] *= s;","m[2][0] *= s;","m[2][1] *= s;","m[2][2] *= s;","m[2][3] *= s;","}","mat3x4 mat34mul(in mat3x4 m1, in mat3x4 m2)","{","mat4 m = mat4(m2[0], m2[1], m2[2], vec4(0.0, 0.0, 0.0, 1.0)) * mat4(m1[0], m1[1], m1[2], vec4(0.0, 0.0, 0.0, 1.0));","return mat3x4(m[0], m[1], m[2]);","}","vec4 quaternionMultiply(in vec4 q1, in vec4 q2)","{","return vec4(cross(q1.xyz, q2.xyz) + q1.w * q2.xyz + q2.w * q1.xyz, q1.w * q2.w - dot(q1.xyz, q2.xyz));","}","mat4 quaternionMatrix4(in vec4 q)","{","float xx = 2.0 * q.x * q.x;","float yy = 2.0 * q.y * q.y;","float zz = 2.0 * q.z * q.z;","float xy = 2.0 * q.x * q.y;","float xz = 2.0 * q.x * q.z;","float yz = 2.0 * q.y * q.z;","float wx = 2.0 * q.w * q.x;","float wy = 2.0 * q.w * q.y;","float wz = 2.0 * q.w * q.z;","return mat4(","1.0 - yy - zz, xy + wz, xz - wy, 0.0,","xy - wz, 1.0 - xx - zz, yz + wx, 0.0,","xz + wy, yz - wx, 1.0 - xx - yy, 0.0,","0.0, 0.0, 0.0, 1.0",");","}","mat3 quaternionMatrix3(in vec4 q)","{","float xx = 2.0 * q.x * q.x;","float yy = 2.0 * q.y * q.y;","float zz = 2.0 * q.z * q.z;","float xy = 2.0 * q.x * q.y;","float xz = 2.0 * q.x * q.z;","float yz = 2.0 * q.y * q.z;","float wx = 2.0 * q.w * q.x;","float wy = 2.0 * q.w * q.y;","float wz = 2.0 * q.w * q.z;","return mat3(","1.0 - yy - zz, xy + wz, xz - wy,","xy - wz, 1.0 - xx - zz, yz + wx,","xz + wy, yz - wx, 1.0 - xx - yy",");","}","vec4 quaternionSlerp(in vec4 qa, in vec4 qb, in float t)","{","float cosHalfTheta = dot(qa, qb);","if (cosHalfTheta >= 0.999999f) return normalize(mix(qa, qb, t));","if (cosHalfTheta <= -0.999999f) return qa;","float halfTheta = acos(cosHalfTheta);","float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);","if (abs(sinHalfTheta) < 0.001) return normalize(mix(qa, qb, t));","float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;","float ratioB = sin(t * halfTheta) / sinHalfTheta;","return qa * ratioA + qb * ratioB;","}","vertAttrib(0, vec3, vertexAttribute0);","vertAttrib(1, vec4, vertexAttribute1);","vertAttrib(2, vec3, vertexAttribute2);","vertAttrib(6, vec3, vertexAttribute6);","vertAttrib(10, vec2, texCoord);","vertAttrib(11, uvec2, vertexAttribute11);","#define vertex1 vertexAttribute0","#define vertex2 vertexAttribute6","#define staticVertex vertexAttribute0","#define skeletalVertex vertexAttribute0","#ifdef WEIGHT_NORMAL_PACKED","#define boneWeight0 (vertexAttribute1.w)","#else","#define boneWeight0 (vertexAttribute2.x)","#endif","#define boneIndices vertexAttribute11","uniform int geometryType;","#define GEOM_MORPH 0","#define GEOM_STATIC 2","#define GEOM_SKELETAL 3","#define GEOM_SKELETAL_INTERANIMATION 4","uniform float interpolationParameter;","smooth out vec2 fragTexCoord;","vec3 interpolateSkeletal()","{","#if defined(BATCHED)","int invIdx = instances[instanceIdx + gl_InstanceID].startIndices[0];","int matIdx = instances[instanceIdx + gl_InstanceID].startIndices[1];","mat3x4 m1 = mat34mul(boneMatrices[matIdx + int(boneIndices.x)], bindInverseMatrices[invIdx + int(boneIndices.x)]);","mat3x4 m2 = mat34mul(boneMatrices[matIdx + int(boneIndices.y)], bindInverseMatrices[invIdx + int(boneIndices.y)]);","#elif defined(SSBO_SKELETON) || defined(UBO_AVAILABLE)","mat3x4 m1 = mat34mul(getBoneMatrix(int(boneIndices.x)), getBindInverse(int(boneIndices.x)));","mat3x4 m2 = mat34mul(getBoneMatrix(int(boneIndices.y)), getBindInverse(int(boneIndices.y)));","#else","mat3x4 m1 = getBoneMatrix(int(boneIndices.x));","mat3x4 m2 = getBoneMatrix(int(boneIndices.y));","#endif","vec3 v1 = (vec4(skeletalVertex, 1.0) * m1).xyz;","vec3 v2 = (vec4(skeletalVertex, 1.0) * m2).xyz;","float boneWeight1 = 1.0 - boneWeight0;","return v1 * boneWeight0 + v2 * boneWeight1;","}","uniform vec4 attachmentDisplacementScale;","#ifdef SSBO_SKELETON","mat3x4 getAttachmentBoneMatrix(in uint index)","{","if (index == 0u) return mat3x4(1.0);","mat3x4 m = boneMatrices[index];","m[0].xyz *= attachmentDisplacementScale.w;","m[1].xyz *= attachmentDisplacementScale.w;","m[2].xyz *= attachmentDisplacementScale.w;","m[0][3] += attachmentDisplacementScale.x;","m[1][3] += attachmentDisplacementScale.y;","m[2][3] += attachmentDisplacementScale.z;","return m;","}","#elif defined(UBO_AVAILABLE)","layout(std140) uniform Skeleton5","{","mat3x4 attachmentMatrices[MAX_BONES];","};","mat3x4 getAttachmentBoneMatrix(in uint index)","{","if (index == 0u) return mat3x4(1.0);","mat3x4 m = attachmentMatrices[index];","m[0].xyz *= attachmentDisplacementScale.w;","m[1].xyz *= attachmentDisplacementScale.w;","m[2].xyz *= attachmentDisplacementScale.w;","m[0][3] += attachmentDisplacementScale.x;","m[1][3] += attachmentDisplacementScale.y;","m[2][3] += attachmentDisplacementScale.z;","return m;","}","#elif defined(CPU_SKELETON)","uniform mat3x4 attachmentMatrix;","mat3x4 getAttachmentBoneMatrix(in uint index) { return attachmentMatrix; }","#else","mat3x4 getAttachmentBoneMatrix(in uint index) { return mat3x4(1.0); }","#endif","void main()","{","#ifdef BATCHED","instanceId = gl_InstanceID;","#endif","vec3 interpolatedVertex;","switch (geometryType) {","case GEOM_MORPH:","interpolatedVertex = mix(vertex1, vertex2, interpolationParameter);","break;","case GEOM_STATIC:","interpolatedVertex = staticVertex;","break;","case GEOM_SKELETAL:","interpolatedVertex = interpolateSkeletal();","break;","default:","interpolatedVertex = vec3(0.0, 0.0, 0.0);","}","fragTexCoord = texCoord;","gl_Position = modelViewProjection * vec4(vec4(interpolatedVertex, 1.0) * getAttachmentBoneMatrix(uint(attachmentBoneIndex)), 1.0);","}"]}}
